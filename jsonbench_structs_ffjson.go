// Code generated by ffjson <https://github.com/pquerna/ffjson>. EDITED TO REMOVE:
// MarshalJSON
// UnmarshalJSON
// source: jsonbench_structs.go

package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"

	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSONBuf marshal buff to json - template
func (j *canadaRoot) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"features":`)
	if j.Features != nil {
		buf.WriteString(`[`)
		for i, v := range j.Features {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Inline struct. type=struct { Type string "json:\"type\""; Properties struct { Name string "json:\"name\"" } "json:\"properties\""; Geometry struct { Type string "json:\"type\""; Coordinates [][][2]float64 "json:\"coordinates\"" } "json:\"geometry\"" } kind=struct */
			buf.WriteString(`{ "type":`)
			fflib.WriteJsonString(buf, string(v.Type))
			/* Inline struct. type=struct { Name string "json:\"name\"" } kind=struct */
			buf.WriteString(`,"properties":{ "name":`)
			fflib.WriteJsonString(buf, string(v.Properties.Name))
			buf.WriteByte('}')
			/* Inline struct. type=struct { Type string "json:\"type\""; Coordinates [][][2]float64 "json:\"coordinates\"" } kind=struct */
			buf.WriteString(`,"geometry":{ "type":`)
			fflib.WriteJsonString(buf, string(v.Geometry.Type))
			buf.WriteString(`,"coordinates":`)
			if v.Geometry.Coordinates != nil {
				buf.WriteString(`[`)
				for i, v := range v.Geometry.Coordinates {
					if i != 0 {
						buf.WriteString(`,`)
					}
					if v != nil {
						buf.WriteString(`[`)
						for i, v := range v {
							if i != 0 {
								buf.WriteString(`,`)
							}
							buf.WriteString(`[`)
							for i, v := range v {
								if i != 0 {
									buf.WriteString(`,`)
								}
								fflib.AppendFloat(buf, float64(v), 'g', -1, 64)
							}
							buf.WriteString(`]`)
						}
						buf.WriteString(`]`)
					} else {
						buf.WriteString(`null`)
					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
			buf.WriteByte('}')
			buf.WriteByte('}')
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtcanadaRootbase = iota
	ffjtcanadaRootnosuchkey

	ffjtcanadaRootType

	ffjtcanadaRootFeatures
)

var ffjKeycanadaRootType = []byte("type")

var ffjKeycanadaRootFeatures = []byte("features")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *canadaRoot) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtcanadaRootbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtcanadaRootnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeycanadaRootFeatures, kn) {
						currentKey = ffjtcanadaRootFeatures
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeycanadaRootType, kn) {
						currentKey = ffjtcanadaRootType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeycanadaRootFeatures, kn) {
					currentKey = ffjtcanadaRootFeatures
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeycanadaRootType, kn) {
					currentKey = ffjtcanadaRootType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtcanadaRootnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtcanadaRootType:
					goto handle_Type

				case ffjtcanadaRootFeatures:
					goto handle_Features

				case ffjtcanadaRootnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Features:

	/* handler: j.Features type=[]struct { Type string "json:\"type\""; Properties struct { Name string "json:\"name\"" } "json:\"properties\""; Geometry struct { Type string "json:\"type\""; Coordinates [][][2]float64 "json:\"coordinates\"" } "json:\"geometry\"" } kind=slice quoted=false*/

	{
		/* Falling back. type=[]struct { Type string "json:\"type\""; Properties struct { Name string "json:\"name\"" } "json:\"properties\""; Geometry struct { Type string "json:\"type\""; Coordinates [][][2]float64 "json:\"coordinates\"" } "json:\"geometry\"" } kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Features)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *citmRoot) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	/* Falling back. type=map[int64]string kind=map */
	buf.WriteString(`{"areaNames":`)
	err = buf.Encode(j.AreaNames)
	if err != nil {
		return err
	}
	/* Falling back. type=map[int64]string kind=map */
	buf.WriteString(`,"audienceSubCategoryNames":`)
	err = buf.Encode(j.AudienceSubCategoryNames)
	if err != nil {
		return err
	}
	/* Falling back. type=map[int64]string kind=map */
	buf.WriteString(`,"blockNames":`)
	err = buf.Encode(j.BlockNames)
	if err != nil {
		return err
	}
	/* Falling back. type=map[int64]struct { Description string "json:\"description\""; ID int "json:\"id\""; Logo string "json:\"logo\""; Name string "json:\"name\""; SubTopicIds []int "json:\"subTopicIds\""; SubjectCode interface {} "json:\"subjectCode\""; Subtitle interface {} "json:\"subtitle\""; TopicIds []int "json:\"topicIds\"" } kind=map */
	buf.WriteString(`,"events":`)
	err = buf.Encode(j.Events)
	if err != nil {
		return err
	}
	buf.WriteString(`,"performances":`)
	if j.Performances != nil {
		buf.WriteString(`[`)
		for i, v := range j.Performances {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Inline struct. type=struct { EventID int "json:\"eventId\""; ID int "json:\"id\""; Logo interface {} "json:\"logo\""; Name interface {} "json:\"name\""; Prices []struct { Amount int "json:\"amount\""; AudienceSubCategoryID int64 "json:\"audienceSubCategoryId\""; SeatCategoryID int64 "json:\"seatCategoryId\"" } "json:\"prices\""; SeatCategories []struct { Areas []struct { AreaID int "json:\"areaId\""; BlockIds []interface {} "json:\"blockIds\"" } "json:\"areas\""; SeatCategoryID int "json:\"seatCategoryId\"" } "json:\"seatCategories\""; SeatMapImage interface {} "json:\"seatMapImage\""; Start int64 "json:\"start\""; VenueCode string "json:\"venueCode\"" } kind=struct */
			buf.WriteString(`{ "eventId":`)
			fflib.FormatBits2(buf, uint64(v.EventID), 10, v.EventID < 0)
			buf.WriteString(`,"id":`)
			fflib.FormatBits2(buf, uint64(v.ID), 10, v.ID < 0)
			buf.WriteString(`,"logo":`)
			/* Interface types must use runtime reflection. type=interface {} kind=interface */
			err = buf.Encode(v.Logo)
			if err != nil {
				return err
			}
			buf.WriteString(`,"name":`)
			/* Interface types must use runtime reflection. type=interface {} kind=interface */
			err = buf.Encode(v.Name)
			if err != nil {
				return err
			}
			buf.WriteString(`,"prices":`)
			if v.Prices != nil {
				buf.WriteString(`[`)
				for i, v := range v.Prices {
					if i != 0 {
						buf.WriteString(`,`)
					}
					/* Inline struct. type=struct { Amount int "json:\"amount\""; AudienceSubCategoryID int64 "json:\"audienceSubCategoryId\""; SeatCategoryID int64 "json:\"seatCategoryId\"" } kind=struct */
					buf.WriteString(`{ "amount":`)
					fflib.FormatBits2(buf, uint64(v.Amount), 10, v.Amount < 0)
					buf.WriteString(`,"audienceSubCategoryId":`)
					fflib.FormatBits2(buf, uint64(v.AudienceSubCategoryID), 10, v.AudienceSubCategoryID < 0)
					buf.WriteString(`,"seatCategoryId":`)
					fflib.FormatBits2(buf, uint64(v.SeatCategoryID), 10, v.SeatCategoryID < 0)
					buf.WriteByte('}')
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
			buf.WriteString(`,"seatCategories":`)
			if v.SeatCategories != nil {
				buf.WriteString(`[`)
				for i, v := range v.SeatCategories {
					if i != 0 {
						buf.WriteString(`,`)
					}
					/* Inline struct. type=struct { Areas []struct { AreaID int "json:\"areaId\""; BlockIds []interface {} "json:\"blockIds\"" } "json:\"areas\""; SeatCategoryID int "json:\"seatCategoryId\"" } kind=struct */
					buf.WriteString(`{ "areas":`)
					if v.Areas != nil {
						buf.WriteString(`[`)
						for i, v := range v.Areas {
							if i != 0 {
								buf.WriteString(`,`)
							}
							/* Inline struct. type=struct { AreaID int "json:\"areaId\""; BlockIds []interface {} "json:\"blockIds\"" } kind=struct */
							buf.WriteString(`{ "areaId":`)
							fflib.FormatBits2(buf, uint64(v.AreaID), 10, v.AreaID < 0)
							buf.WriteString(`,"blockIds":`)
							if v.BlockIds != nil {
								buf.WriteString(`[`)
								for i, v := range v.BlockIds {
									if i != 0 {
										buf.WriteString(`,`)
									}
									/* Interface types must use runtime reflection. type=interface {} kind=interface */
									err = buf.Encode(v)
									if err != nil {
										return err
									}
								}
								buf.WriteString(`]`)
							} else {
								buf.WriteString(`null`)
							}
							buf.WriteByte('}')
						}
						buf.WriteString(`]`)
					} else {
						buf.WriteString(`null`)
					}
					buf.WriteString(`,"seatCategoryId":`)
					fflib.FormatBits2(buf, uint64(v.SeatCategoryID), 10, v.SeatCategoryID < 0)
					buf.WriteByte('}')
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
			buf.WriteString(`,"seatMapImage":`)
			/* Interface types must use runtime reflection. type=interface {} kind=interface */
			err = buf.Encode(v.SeatMapImage)
			if err != nil {
				return err
			}
			buf.WriteString(`,"start":`)
			fflib.FormatBits2(buf, uint64(v.Start), 10, v.Start < 0)
			buf.WriteString(`,"venueCode":`)
			fflib.WriteJsonString(buf, string(v.VenueCode))
			buf.WriteByte('}')
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	/* Falling back. type=map[uint64]string kind=map */
	buf.WriteString(`,"seatCategoryNames":`)
	err = buf.Encode(j.SeatCategoryNames)
	if err != nil {
		return err
	}
	/* Falling back. type=map[uint64]string kind=map */
	buf.WriteString(`,"subTopicNames":`)
	err = buf.Encode(j.SubTopicNames)
	if err != nil {
		return err
	}
	/* Falling back. type=map[uint64]string kind=map */
	buf.WriteString(`,"subjectNames":`)
	err = buf.Encode(j.SubjectNames)
	if err != nil {
		return err
	}
	/* Falling back. type=map[uint64]string kind=map */
	buf.WriteString(`,"topicNames":`)
	err = buf.Encode(j.TopicNames)
	if err != nil {
		return err
	}
	/* Falling back. type=map[uint64][]uint64 kind=map */
	buf.WriteString(`,"topicSubTopics":`)
	err = buf.Encode(j.TopicSubTopics)
	if err != nil {
		return err
	}
	if j.VenueNames == nil {
		buf.WriteString(`,"venueNames":null`)
	} else {
		buf.WriteString(`,"venueNames":{ `)
		for key, value := range j.VenueNames {
			fflib.WriteJsonString(buf, key)
			buf.WriteString(`:`)
			fflib.WriteJsonString(buf, string(value))
			buf.WriteByte(',')
		}
		buf.Rewind(1)
		buf.WriteByte('}')
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtcitmRootbase = iota
	ffjtcitmRootnosuchkey

	ffjtcitmRootAreaNames

	ffjtcitmRootAudienceSubCategoryNames

	ffjtcitmRootBlockNames

	ffjtcitmRootEvents

	ffjtcitmRootPerformances

	ffjtcitmRootSeatCategoryNames

	ffjtcitmRootSubTopicNames

	ffjtcitmRootSubjectNames

	ffjtcitmRootTopicNames

	ffjtcitmRootTopicSubTopics

	ffjtcitmRootVenueNames
)

var ffjKeycitmRootAreaNames = []byte("areaNames")

var ffjKeycitmRootAudienceSubCategoryNames = []byte("audienceSubCategoryNames")

var ffjKeycitmRootBlockNames = []byte("blockNames")

var ffjKeycitmRootEvents = []byte("events")

var ffjKeycitmRootPerformances = []byte("performances")

var ffjKeycitmRootSeatCategoryNames = []byte("seatCategoryNames")

var ffjKeycitmRootSubTopicNames = []byte("subTopicNames")

var ffjKeycitmRootSubjectNames = []byte("subjectNames")

var ffjKeycitmRootTopicNames = []byte("topicNames")

var ffjKeycitmRootTopicSubTopics = []byte("topicSubTopics")

var ffjKeycitmRootVenueNames = []byte("venueNames")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *citmRoot) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtcitmRootbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtcitmRootnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeycitmRootAreaNames, kn) {
						currentKey = ffjtcitmRootAreaNames
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeycitmRootAudienceSubCategoryNames, kn) {
						currentKey = ffjtcitmRootAudienceSubCategoryNames
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeycitmRootBlockNames, kn) {
						currentKey = ffjtcitmRootBlockNames
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeycitmRootEvents, kn) {
						currentKey = ffjtcitmRootEvents
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeycitmRootPerformances, kn) {
						currentKey = ffjtcitmRootPerformances
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeycitmRootSeatCategoryNames, kn) {
						currentKey = ffjtcitmRootSeatCategoryNames
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeycitmRootSubTopicNames, kn) {
						currentKey = ffjtcitmRootSubTopicNames
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeycitmRootSubjectNames, kn) {
						currentKey = ffjtcitmRootSubjectNames
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeycitmRootTopicNames, kn) {
						currentKey = ffjtcitmRootTopicNames
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeycitmRootTopicSubTopics, kn) {
						currentKey = ffjtcitmRootTopicSubTopics
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeycitmRootVenueNames, kn) {
						currentKey = ffjtcitmRootVenueNames
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeycitmRootVenueNames, kn) {
					currentKey = ffjtcitmRootVenueNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycitmRootTopicSubTopics, kn) {
					currentKey = ffjtcitmRootTopicSubTopics
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycitmRootTopicNames, kn) {
					currentKey = ffjtcitmRootTopicNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycitmRootSubjectNames, kn) {
					currentKey = ffjtcitmRootSubjectNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycitmRootSubTopicNames, kn) {
					currentKey = ffjtcitmRootSubTopicNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycitmRootSeatCategoryNames, kn) {
					currentKey = ffjtcitmRootSeatCategoryNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycitmRootPerformances, kn) {
					currentKey = ffjtcitmRootPerformances
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycitmRootEvents, kn) {
					currentKey = ffjtcitmRootEvents
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycitmRootBlockNames, kn) {
					currentKey = ffjtcitmRootBlockNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycitmRootAudienceSubCategoryNames, kn) {
					currentKey = ffjtcitmRootAudienceSubCategoryNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycitmRootAreaNames, kn) {
					currentKey = ffjtcitmRootAreaNames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtcitmRootnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtcitmRootAreaNames:
					goto handle_AreaNames

				case ffjtcitmRootAudienceSubCategoryNames:
					goto handle_AudienceSubCategoryNames

				case ffjtcitmRootBlockNames:
					goto handle_BlockNames

				case ffjtcitmRootEvents:
					goto handle_Events

				case ffjtcitmRootPerformances:
					goto handle_Performances

				case ffjtcitmRootSeatCategoryNames:
					goto handle_SeatCategoryNames

				case ffjtcitmRootSubTopicNames:
					goto handle_SubTopicNames

				case ffjtcitmRootSubjectNames:
					goto handle_SubjectNames

				case ffjtcitmRootTopicNames:
					goto handle_TopicNames

				case ffjtcitmRootTopicSubTopics:
					goto handle_TopicSubTopics

				case ffjtcitmRootVenueNames:
					goto handle_VenueNames

				case ffjtcitmRootnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AreaNames:

	/* handler: j.AreaNames type=map[int64]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.AreaNames = nil
		} else {

			j.AreaNames = make(map[int64]string, 0)

			wantVal := true

			for {

				var k int64

				var tmpJAreaNames string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=int64 kind=int64 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						k = int64(tval)

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJAreaNames type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJAreaNames = string(string(outBuf))

					}
				}

				j.AreaNames[k] = tmpJAreaNames

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AudienceSubCategoryNames:

	/* handler: j.AudienceSubCategoryNames type=map[int64]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.AudienceSubCategoryNames = nil
		} else {

			j.AudienceSubCategoryNames = make(map[int64]string, 0)

			wantVal := true

			for {

				var k int64

				var tmpJAudienceSubCategoryNames string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=int64 kind=int64 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						k = int64(tval)

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJAudienceSubCategoryNames type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJAudienceSubCategoryNames = string(string(outBuf))

					}
				}

				j.AudienceSubCategoryNames[k] = tmpJAudienceSubCategoryNames

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BlockNames:

	/* handler: j.BlockNames type=map[int64]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.BlockNames = nil
		} else {

			j.BlockNames = make(map[int64]string, 0)

			wantVal := true

			for {

				var k int64

				var tmpJBlockNames string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=int64 kind=int64 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						k = int64(tval)

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJBlockNames type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJBlockNames = string(string(outBuf))

					}
				}

				j.BlockNames[k] = tmpJBlockNames

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Events:

	/* handler: j.Events type=map[int64]struct { Description string "json:\"description\""; ID int "json:\"id\""; Logo string "json:\"logo\""; Name string "json:\"name\""; SubTopicIds []int "json:\"subTopicIds\""; SubjectCode interface {} "json:\"subjectCode\""; Subtitle interface {} "json:\"subtitle\""; TopicIds []int "json:\"topicIds\"" } kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Events = nil
		} else {

			j.Events = make(map[int64]struct {
				Description string      "json:\"description\""
				ID          int         "json:\"id\""
				Logo        string      "json:\"logo\""
				Name        string      "json:\"name\""
				SubTopicIds []int       "json:\"subTopicIds\""
				SubjectCode interface{} "json:\"subjectCode\""
				Subtitle    interface{} "json:\"subtitle\""
				TopicIds    []int       "json:\"topicIds\""
			}, 0)

			wantVal := true

			for {

				var k int64

				var tmpJEvents struct {
					Description string      "json:\"description\""
					ID          int         "json:\"id\""
					Logo        string      "json:\"logo\""
					Name        string      "json:\"name\""
					SubTopicIds []int       "json:\"subTopicIds\""
					SubjectCode interface{} "json:\"subjectCode\""
					Subtitle    interface{} "json:\"subtitle\""
					TopicIds    []int       "json:\"topicIds\""
				}

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=int64 kind=int64 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						k = int64(tval)

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJEvents type=struct { Description string "json:\"description\""; ID int "json:\"id\""; Logo string "json:\"logo\""; Name string "json:\"name\""; SubTopicIds []int "json:\"subTopicIds\""; SubjectCode interface {} "json:\"subjectCode\""; Subtitle interface {} "json:\"subtitle\""; TopicIds []int "json:\"topicIds\"" } kind=struct quoted=false*/

				{
					/* Falling back. type=struct { Description string "json:\"description\""; ID int "json:\"id\""; Logo string "json:\"logo\""; Name string "json:\"name\""; SubTopicIds []int "json:\"subTopicIds\""; SubjectCode interface {} "json:\"subjectCode\""; Subtitle interface {} "json:\"subtitle\""; TopicIds []int "json:\"topicIds\"" } kind=struct */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJEvents)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.Events[k] = tmpJEvents

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Performances:

	/* handler: j.Performances type=[]struct { EventID int "json:\"eventId\""; ID int "json:\"id\""; Logo interface {} "json:\"logo\""; Name interface {} "json:\"name\""; Prices []struct { Amount int "json:\"amount\""; AudienceSubCategoryID int64 "json:\"audienceSubCategoryId\""; SeatCategoryID int64 "json:\"seatCategoryId\"" } "json:\"prices\""; SeatCategories []struct { Areas []struct { AreaID int "json:\"areaId\""; BlockIds []interface {} "json:\"blockIds\"" } "json:\"areas\""; SeatCategoryID int "json:\"seatCategoryId\"" } "json:\"seatCategories\""; SeatMapImage interface {} "json:\"seatMapImage\""; Start int64 "json:\"start\""; VenueCode string "json:\"venueCode\"" } kind=slice quoted=false*/

	{
		/* Falling back. type=[]struct { EventID int "json:\"eventId\""; ID int "json:\"id\""; Logo interface {} "json:\"logo\""; Name interface {} "json:\"name\""; Prices []struct { Amount int "json:\"amount\""; AudienceSubCategoryID int64 "json:\"audienceSubCategoryId\""; SeatCategoryID int64 "json:\"seatCategoryId\"" } "json:\"prices\""; SeatCategories []struct { Areas []struct { AreaID int "json:\"areaId\""; BlockIds []interface {} "json:\"blockIds\"" } "json:\"areas\""; SeatCategoryID int "json:\"seatCategoryId\"" } "json:\"seatCategories\""; SeatMapImage interface {} "json:\"seatMapImage\""; Start int64 "json:\"start\""; VenueCode string "json:\"venueCode\"" } kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Performances)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SeatCategoryNames:

	/* handler: j.SeatCategoryNames type=map[uint64]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.SeatCategoryNames = nil
		} else {

			j.SeatCategoryNames = make(map[uint64]string, 0)

			wantVal := true

			for {

				var k uint64

				var tmpJSeatCategoryNames string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=uint64 kind=uint64 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						k = uint64(tval)

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJSeatCategoryNames type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJSeatCategoryNames = string(string(outBuf))

					}
				}

				j.SeatCategoryNames[k] = tmpJSeatCategoryNames

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SubTopicNames:

	/* handler: j.SubTopicNames type=map[uint64]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.SubTopicNames = nil
		} else {

			j.SubTopicNames = make(map[uint64]string, 0)

			wantVal := true

			for {

				var k uint64

				var tmpJSubTopicNames string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=uint64 kind=uint64 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						k = uint64(tval)

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJSubTopicNames type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJSubTopicNames = string(string(outBuf))

					}
				}

				j.SubTopicNames[k] = tmpJSubTopicNames

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SubjectNames:

	/* handler: j.SubjectNames type=map[uint64]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.SubjectNames = nil
		} else {

			j.SubjectNames = make(map[uint64]string, 0)

			wantVal := true

			for {

				var k uint64

				var tmpJSubjectNames string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=uint64 kind=uint64 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						k = uint64(tval)

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJSubjectNames type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJSubjectNames = string(string(outBuf))

					}
				}

				j.SubjectNames[k] = tmpJSubjectNames

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TopicNames:

	/* handler: j.TopicNames type=map[uint64]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.TopicNames = nil
		} else {

			j.TopicNames = make(map[uint64]string, 0)

			wantVal := true

			for {

				var k uint64

				var tmpJTopicNames string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=uint64 kind=uint64 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						k = uint64(tval)

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJTopicNames type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJTopicNames = string(string(outBuf))

					}
				}

				j.TopicNames[k] = tmpJTopicNames

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TopicSubTopics:

	/* handler: j.TopicSubTopics type=map[uint64][]uint64 kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.TopicSubTopics = nil
		} else {

			j.TopicSubTopics = make(map[uint64][]uint64, 0)

			wantVal := true

			for {

				var k uint64

				var tmpJTopicSubTopics []uint64

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=uint64 kind=uint64 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						k = uint64(tval)

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJTopicSubTopics type=[]uint64 kind=slice quoted=false*/

				{

					{
						if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
						}
					}

					if tok == fflib.FFTok_null {
						tmpJTopicSubTopics = nil
					} else {

						tmpJTopicSubTopics = []uint64{}

						wantVal := true

						for {

							var tmpTmpJTopicSubTopics uint64

							tok = fs.Scan()
							if tok == fflib.FFTok_error {
								goto tokerror
							}
							if tok == fflib.FFTok_right_brace {
								break
							}

							if tok == fflib.FFTok_comma {
								if wantVal == true {
									// TODO(pquerna): this isn't an ideal error message, this handles
									// things like [,,,] as an array value.
									return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
								}
								continue
							} else {
								wantVal = true
							}

							/* handler: tmpTmpJTopicSubTopics type=uint64 kind=uint64 quoted=false*/

							{
								if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
									return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
								}
							}

							{

								if tok == fflib.FFTok_null {

								} else {

									tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

									if err != nil {
										return fs.WrapErr(err)
									}

									tmpTmpJTopicSubTopics = uint64(tval)

								}
							}

							tmpJTopicSubTopics = append(tmpJTopicSubTopics, tmpTmpJTopicSubTopics)

							wantVal = false
						}
					}
				}

				j.TopicSubTopics[k] = tmpJTopicSubTopics

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VenueNames:

	/* handler: j.VenueNames type=map[string]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.VenueNames = nil
		} else {

			j.VenueNames = make(map[string]string, 0)

			wantVal := true

			for {

				var k string

				var tmpJVenueNames string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJVenueNames type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJVenueNames = string(string(outBuf))

					}
				}

				j.VenueNames[k] = tmpJVenueNames

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *golangNode) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"kids":`)
	if j.Kids != nil {
		buf.WriteString(`[`)
		for i, v := range j.Kids {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"cl_weight":`)
	fflib.AppendFloat(buf, float64(j.CLWeight), 'g', -1, 64)
	buf.WriteString(`,"touches":`)
	fflib.FormatBits2(buf, uint64(j.Touches), 10, j.Touches < 0)
	buf.WriteString(`,"min_t":`)
	fflib.FormatBits2(buf, uint64(j.MinT), 10, false)
	buf.WriteString(`,"max_t":`)
	fflib.FormatBits2(buf, uint64(j.MaxT), 10, false)
	buf.WriteString(`,"mean_t":`)
	fflib.FormatBits2(buf, uint64(j.MeanT), 10, false)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtgolangNodebase = iota
	ffjtgolangNodenosuchkey

	ffjtgolangNodeName

	ffjtgolangNodeKids

	ffjtgolangNodeCLWeight

	ffjtgolangNodeTouches

	ffjtgolangNodeMinT

	ffjtgolangNodeMaxT

	ffjtgolangNodeMeanT
)

var ffjKeygolangNodeName = []byte("name")

var ffjKeygolangNodeKids = []byte("kids")

var ffjKeygolangNodeCLWeight = []byte("cl_weight")

var ffjKeygolangNodeTouches = []byte("touches")

var ffjKeygolangNodeMinT = []byte("min_t")

var ffjKeygolangNodeMaxT = []byte("max_t")

var ffjKeygolangNodeMeanT = []byte("mean_t")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *golangNode) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtgolangNodebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtgolangNodenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeygolangNodeCLWeight, kn) {
						currentKey = ffjtgolangNodeCLWeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffjKeygolangNodeKids, kn) {
						currentKey = ffjtgolangNodeKids
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeygolangNodeMinT, kn) {
						currentKey = ffjtgolangNodeMinT
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeygolangNodeMaxT, kn) {
						currentKey = ffjtgolangNodeMaxT
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeygolangNodeMeanT, kn) {
						currentKey = ffjtgolangNodeMeanT
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeygolangNodeName, kn) {
						currentKey = ffjtgolangNodeName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeygolangNodeTouches, kn) {
						currentKey = ffjtgolangNodeTouches
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeygolangNodeMeanT, kn) {
					currentKey = ffjtgolangNodeMeanT
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeygolangNodeMaxT, kn) {
					currentKey = ffjtgolangNodeMaxT
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeygolangNodeMinT, kn) {
					currentKey = ffjtgolangNodeMinT
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeygolangNodeTouches, kn) {
					currentKey = ffjtgolangNodeTouches
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeygolangNodeCLWeight, kn) {
					currentKey = ffjtgolangNodeCLWeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeygolangNodeKids, kn) {
					currentKey = ffjtgolangNodeKids
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeygolangNodeName, kn) {
					currentKey = ffjtgolangNodeName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtgolangNodenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtgolangNodeName:
					goto handle_Name

				case ffjtgolangNodeKids:
					goto handle_Kids

				case ffjtgolangNodeCLWeight:
					goto handle_CLWeight

				case ffjtgolangNodeTouches:
					goto handle_Touches

				case ffjtgolangNodeMinT:
					goto handle_MinT

				case ffjtgolangNodeMaxT:
					goto handle_MaxT

				case ffjtgolangNodeMeanT:
					goto handle_MeanT

				case ffjtgolangNodenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kids:

	/* handler: j.Kids type=[]tmp.golangNode kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Kids = nil
		} else {

			j.Kids = []golangNode{}

			wantVal := true

			for {

				var tmpJKids golangNode

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJKids type=tmp.golangNode kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJKids.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Kids = append(j.Kids, tmpJKids)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CLWeight:

	/* handler: j.CLWeight type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.CLWeight = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Touches:

	/* handler: j.Touches type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Touches = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MinT:

	/* handler: j.MinT type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MinT = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxT:

	/* handler: j.MaxT type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaxT = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MeanT:

	/* handler: j.MeanT type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MeanT = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *golangRoot) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Tree != nil {
		buf.WriteString(`{"tree":`)

		{

			err = j.Tree.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`{"tree":null`)
	}
	buf.WriteString(`,"username":`)
	fflib.WriteJsonString(buf, string(j.Username))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtgolangRootbase = iota
	ffjtgolangRootnosuchkey

	ffjtgolangRootTree

	ffjtgolangRootUsername
)

var ffjKeygolangRootTree = []byte("tree")

var ffjKeygolangRootUsername = []byte("username")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *golangRoot) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtgolangRootbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtgolangRootnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 't':

					if bytes.Equal(ffjKeygolangRootTree, kn) {
						currentKey = ffjtgolangRootTree
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeygolangRootUsername, kn) {
						currentKey = ffjtgolangRootUsername
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeygolangRootUsername, kn) {
					currentKey = ffjtgolangRootUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeygolangRootTree, kn) {
					currentKey = ffjtgolangRootTree
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtgolangRootnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtgolangRootTree:
					goto handle_Tree

				case ffjtgolangRootUsername:
					goto handle_Username

				case ffjtgolangRootnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Tree:

	/* handler: j.Tree type=tmp.golangNode kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Tree = nil

		} else {

			if j.Tree == nil {
				j.Tree = new(golangNode)
			}

			err = j.Tree.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: j.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *stringRoot) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Arabic":`)
	fflib.WriteJsonString(buf, string(j.Arabic))
	buf.WriteString(`,"Arabic Presentation Forms-A":`)
	fflib.WriteJsonString(buf, string(j.ArabicPresentationFormsA))
	buf.WriteString(`,"Arabic Presentation Forms-B":`)
	fflib.WriteJsonString(buf, string(j.ArabicPresentationFormsB))
	buf.WriteString(`,"Armenian":`)
	fflib.WriteJsonString(buf, string(j.Armenian))
	buf.WriteString(`,"Arrows":`)
	fflib.WriteJsonString(buf, string(j.Arrows))
	buf.WriteString(`,"Bengali":`)
	fflib.WriteJsonString(buf, string(j.Bengali))
	buf.WriteString(`,"Bopomofo":`)
	fflib.WriteJsonString(buf, string(j.Bopomofo))
	buf.WriteString(`,"Box Drawing":`)
	fflib.WriteJsonString(buf, string(j.BoxDrawing))
	buf.WriteString(`,"CJK Compatibility":`)
	fflib.WriteJsonString(buf, string(j.CJKCompatibility))
	buf.WriteString(`,"CJK Compatibility Forms":`)
	fflib.WriteJsonString(buf, string(j.CJKCompatibilityForms))
	buf.WriteString(`,"CJK Compatibility Ideographs":`)
	fflib.WriteJsonString(buf, string(j.CJKCompatibilityIdeographs))
	buf.WriteString(`,"CJK Symbols and Punctuation":`)
	fflib.WriteJsonString(buf, string(j.CJKSymbolsAndPunctuation))
	buf.WriteString(`,"CJK Unified Ideographs":`)
	fflib.WriteJsonString(buf, string(j.CJKUnifiedIdeographs))
	buf.WriteString(`,"CJK Unified Ideographs Extension A":`)
	fflib.WriteJsonString(buf, string(j.CJKUnifiedIdeographsExtensionA))
	buf.WriteString(`,"CJK Unified Ideographs Extension B":`)
	fflib.WriteJsonString(buf, string(j.CJKUnifiedIdeographsExtensionB))
	buf.WriteString(`,"Cherokee":`)
	fflib.WriteJsonString(buf, string(j.Cherokee))
	buf.WriteString(`,"Currency Symbols":`)
	fflib.WriteJsonString(buf, string(j.CurrencySymbols))
	buf.WriteString(`,"Cyrillic":`)
	fflib.WriteJsonString(buf, string(j.Cyrillic))
	buf.WriteString(`,"Cyrillic Supplementary":`)
	fflib.WriteJsonString(buf, string(j.CyrillicSupplementary))
	buf.WriteString(`,"Devanagari":`)
	fflib.WriteJsonString(buf, string(j.Devanagari))
	buf.WriteString(`,"Enclosed Alphanumerics":`)
	fflib.WriteJsonString(buf, string(j.EnclosedAlphanumerics))
	buf.WriteString(`,"Enclosed CJK Letters and Months":`)
	fflib.WriteJsonString(buf, string(j.EnclosedCJKLettersAndMonths))
	buf.WriteString(`,"Ethiopic":`)
	fflib.WriteJsonString(buf, string(j.Ethiopic))
	buf.WriteString(`,"Geometric Shapes":`)
	fflib.WriteJsonString(buf, string(j.GeometricShapes))
	buf.WriteString(`,"Georgian":`)
	fflib.WriteJsonString(buf, string(j.Georgian))
	buf.WriteString(`,"Greek and Coptic":`)
	fflib.WriteJsonString(buf, string(j.GreekAndCoptic))
	buf.WriteString(`,"Gujarati":`)
	fflib.WriteJsonString(buf, string(j.Gujarati))
	buf.WriteString(`,"Gurmukhi":`)
	fflib.WriteJsonString(buf, string(j.Gurmukhi))
	buf.WriteString(`,"Hangul Compatibility Jamo":`)
	fflib.WriteJsonString(buf, string(j.HangulCompatibilityJamo))
	buf.WriteString(`,"Hangul Jamo":`)
	fflib.WriteJsonString(buf, string(j.HangulJamo))
	buf.WriteString(`,"Hangul Syllables":`)
	fflib.WriteJsonString(buf, string(j.HangulSyllables))
	buf.WriteString(`,"Hebrew":`)
	fflib.WriteJsonString(buf, string(j.Hebrew))
	buf.WriteString(`,"Hiragana":`)
	fflib.WriteJsonString(buf, string(j.Hiragana))
	buf.WriteString(`,"IPA Extentions":`)
	fflib.WriteJsonString(buf, string(j.IPAExtentions))
	buf.WriteString(`,"Kangxi Radicals":`)
	fflib.WriteJsonString(buf, string(j.KangxiRadicals))
	buf.WriteString(`,"Katakana":`)
	fflib.WriteJsonString(buf, string(j.Katakana))
	buf.WriteString(`,"Khmer":`)
	fflib.WriteJsonString(buf, string(j.Khmer))
	buf.WriteString(`,"Khmer Symbols":`)
	fflib.WriteJsonString(buf, string(j.KhmerSymbols))
	buf.WriteString(`,"Latin":`)
	fflib.WriteJsonString(buf, string(j.Latin))
	buf.WriteString(`,"Latin Extended Additional":`)
	fflib.WriteJsonString(buf, string(j.LatinExtendedAdditional))
	buf.WriteString(`,"Latin-1 Supplement":`)
	fflib.WriteJsonString(buf, string(j.Latin1Supplement))
	buf.WriteString(`,"Latin-Extended A":`)
	fflib.WriteJsonString(buf, string(j.LatinExtendedA))
	buf.WriteString(`,"Latin-Extended B":`)
	fflib.WriteJsonString(buf, string(j.LatinExtendedB))
	buf.WriteString(`,"Letterlike Symbols":`)
	fflib.WriteJsonString(buf, string(j.LetterlikeSymbols))
	buf.WriteString(`,"Malayalam":`)
	fflib.WriteJsonString(buf, string(j.Malayalam))
	buf.WriteString(`,"Mathematical Alphanumeric Symbols":`)
	fflib.WriteJsonString(buf, string(j.MathematicalAlphanumericSymbols))
	buf.WriteString(`,"Mathematical Operators":`)
	fflib.WriteJsonString(buf, string(j.MathematicalOperators))
	buf.WriteString(`,"Miscellaneous Symbols":`)
	fflib.WriteJsonString(buf, string(j.MiscellaneousSymbols))
	buf.WriteString(`,"Mongolian":`)
	fflib.WriteJsonString(buf, string(j.Mongolian))
	buf.WriteString(`,"Number Forms":`)
	fflib.WriteJsonString(buf, string(j.NumberForms))
	buf.WriteString(`,"Oriya":`)
	fflib.WriteJsonString(buf, string(j.Oriya))
	buf.WriteString(`,"Phonetic Extensions":`)
	fflib.WriteJsonString(buf, string(j.PhoneticExtensions))
	buf.WriteString(`,"Supplemental Arrows-B":`)
	fflib.WriteJsonString(buf, string(j.SupplementalArrowsB))
	buf.WriteString(`,"Syriac":`)
	fflib.WriteJsonString(buf, string(j.Syriac))
	buf.WriteString(`,"Tamil":`)
	fflib.WriteJsonString(buf, string(j.Tamil))
	buf.WriteString(`,"Thaana":`)
	fflib.WriteJsonString(buf, string(j.Thaana))
	buf.WriteString(`,"Thai":`)
	fflib.WriteJsonString(buf, string(j.Thai))
	buf.WriteString(`,"Unified Canadian Aboriginal Syllabics":`)
	fflib.WriteJsonString(buf, string(j.UnifiedCanadianAboriginalSyllabics))
	buf.WriteString(`,"Yi Radicals":`)
	fflib.WriteJsonString(buf, string(j.YiRadicals))
	buf.WriteString(`,"Yi Syllables":`)
	fflib.WriteJsonString(buf, string(j.YiSyllables))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtstringRootbase = iota
	ffjtstringRootnosuchkey

	ffjtstringRootArabic

	ffjtstringRootArabicPresentationFormsA

	ffjtstringRootArabicPresentationFormsB

	ffjtstringRootArmenian

	ffjtstringRootArrows

	ffjtstringRootBengali

	ffjtstringRootBopomofo

	ffjtstringRootBoxDrawing

	ffjtstringRootCJKCompatibility

	ffjtstringRootCJKCompatibilityForms

	ffjtstringRootCJKCompatibilityIdeographs

	ffjtstringRootCJKSymbolsAndPunctuation

	ffjtstringRootCJKUnifiedIdeographs

	ffjtstringRootCJKUnifiedIdeographsExtensionA

	ffjtstringRootCJKUnifiedIdeographsExtensionB

	ffjtstringRootCherokee

	ffjtstringRootCurrencySymbols

	ffjtstringRootCyrillic

	ffjtstringRootCyrillicSupplementary

	ffjtstringRootDevanagari

	ffjtstringRootEnclosedAlphanumerics

	ffjtstringRootEnclosedCJKLettersAndMonths

	ffjtstringRootEthiopic

	ffjtstringRootGeometricShapes

	ffjtstringRootGeorgian

	ffjtstringRootGreekAndCoptic

	ffjtstringRootGujarati

	ffjtstringRootGurmukhi

	ffjtstringRootHangulCompatibilityJamo

	ffjtstringRootHangulJamo

	ffjtstringRootHangulSyllables

	ffjtstringRootHebrew

	ffjtstringRootHiragana

	ffjtstringRootIPAExtentions

	ffjtstringRootKangxiRadicals

	ffjtstringRootKatakana

	ffjtstringRootKhmer

	ffjtstringRootKhmerSymbols

	ffjtstringRootLatin

	ffjtstringRootLatinExtendedAdditional

	ffjtstringRootLatin1Supplement

	ffjtstringRootLatinExtendedA

	ffjtstringRootLatinExtendedB

	ffjtstringRootLetterlikeSymbols

	ffjtstringRootMalayalam

	ffjtstringRootMathematicalAlphanumericSymbols

	ffjtstringRootMathematicalOperators

	ffjtstringRootMiscellaneousSymbols

	ffjtstringRootMongolian

	ffjtstringRootNumberForms

	ffjtstringRootOriya

	ffjtstringRootPhoneticExtensions

	ffjtstringRootSupplementalArrowsB

	ffjtstringRootSyriac

	ffjtstringRootTamil

	ffjtstringRootThaana

	ffjtstringRootThai

	ffjtstringRootUnifiedCanadianAboriginalSyllabics

	ffjtstringRootYiRadicals

	ffjtstringRootYiSyllables
)

var ffjKeystringRootArabic = []byte("Arabic")

var ffjKeystringRootArabicPresentationFormsA = []byte("Arabic Presentation Forms-A")

var ffjKeystringRootArabicPresentationFormsB = []byte("Arabic Presentation Forms-B")

var ffjKeystringRootArmenian = []byte("Armenian")

var ffjKeystringRootArrows = []byte("Arrows")

var ffjKeystringRootBengali = []byte("Bengali")

var ffjKeystringRootBopomofo = []byte("Bopomofo")

var ffjKeystringRootBoxDrawing = []byte("Box Drawing")

var ffjKeystringRootCJKCompatibility = []byte("CJK Compatibility")

var ffjKeystringRootCJKCompatibilityForms = []byte("CJK Compatibility Forms")

var ffjKeystringRootCJKCompatibilityIdeographs = []byte("CJK Compatibility Ideographs")

var ffjKeystringRootCJKSymbolsAndPunctuation = []byte("CJK Symbols and Punctuation")

var ffjKeystringRootCJKUnifiedIdeographs = []byte("CJK Unified Ideographs")

var ffjKeystringRootCJKUnifiedIdeographsExtensionA = []byte("CJK Unified Ideographs Extension A")

var ffjKeystringRootCJKUnifiedIdeographsExtensionB = []byte("CJK Unified Ideographs Extension B")

var ffjKeystringRootCherokee = []byte("Cherokee")

var ffjKeystringRootCurrencySymbols = []byte("Currency Symbols")

var ffjKeystringRootCyrillic = []byte("Cyrillic")

var ffjKeystringRootCyrillicSupplementary = []byte("Cyrillic Supplementary")

var ffjKeystringRootDevanagari = []byte("Devanagari")

var ffjKeystringRootEnclosedAlphanumerics = []byte("Enclosed Alphanumerics")

var ffjKeystringRootEnclosedCJKLettersAndMonths = []byte("Enclosed CJK Letters and Months")

var ffjKeystringRootEthiopic = []byte("Ethiopic")

var ffjKeystringRootGeometricShapes = []byte("Geometric Shapes")

var ffjKeystringRootGeorgian = []byte("Georgian")

var ffjKeystringRootGreekAndCoptic = []byte("Greek and Coptic")

var ffjKeystringRootGujarati = []byte("Gujarati")

var ffjKeystringRootGurmukhi = []byte("Gurmukhi")

var ffjKeystringRootHangulCompatibilityJamo = []byte("Hangul Compatibility Jamo")

var ffjKeystringRootHangulJamo = []byte("Hangul Jamo")

var ffjKeystringRootHangulSyllables = []byte("Hangul Syllables")

var ffjKeystringRootHebrew = []byte("Hebrew")

var ffjKeystringRootHiragana = []byte("Hiragana")

var ffjKeystringRootIPAExtentions = []byte("IPA Extentions")

var ffjKeystringRootKangxiRadicals = []byte("Kangxi Radicals")

var ffjKeystringRootKatakana = []byte("Katakana")

var ffjKeystringRootKhmer = []byte("Khmer")

var ffjKeystringRootKhmerSymbols = []byte("Khmer Symbols")

var ffjKeystringRootLatin = []byte("Latin")

var ffjKeystringRootLatinExtendedAdditional = []byte("Latin Extended Additional")

var ffjKeystringRootLatin1Supplement = []byte("Latin-1 Supplement")

var ffjKeystringRootLatinExtendedA = []byte("Latin-Extended A")

var ffjKeystringRootLatinExtendedB = []byte("Latin-Extended B")

var ffjKeystringRootLetterlikeSymbols = []byte("Letterlike Symbols")

var ffjKeystringRootMalayalam = []byte("Malayalam")

var ffjKeystringRootMathematicalAlphanumericSymbols = []byte("Mathematical Alphanumeric Symbols")

var ffjKeystringRootMathematicalOperators = []byte("Mathematical Operators")

var ffjKeystringRootMiscellaneousSymbols = []byte("Miscellaneous Symbols")

var ffjKeystringRootMongolian = []byte("Mongolian")

var ffjKeystringRootNumberForms = []byte("Number Forms")

var ffjKeystringRootOriya = []byte("Oriya")

var ffjKeystringRootPhoneticExtensions = []byte("Phonetic Extensions")

var ffjKeystringRootSupplementalArrowsB = []byte("Supplemental Arrows-B")

var ffjKeystringRootSyriac = []byte("Syriac")

var ffjKeystringRootTamil = []byte("Tamil")

var ffjKeystringRootThaana = []byte("Thaana")

var ffjKeystringRootThai = []byte("Thai")

var ffjKeystringRootUnifiedCanadianAboriginalSyllabics = []byte("Unified Canadian Aboriginal Syllabics")

var ffjKeystringRootYiRadicals = []byte("Yi Radicals")

var ffjKeystringRootYiSyllables = []byte("Yi Syllables")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *stringRoot) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtstringRootbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtstringRootnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffjKeystringRootArabic, kn) {
						currentKey = ffjtstringRootArabic
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootArabicPresentationFormsA, kn) {
						currentKey = ffjtstringRootArabicPresentationFormsA
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootArabicPresentationFormsB, kn) {
						currentKey = ffjtstringRootArabicPresentationFormsB
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootArmenian, kn) {
						currentKey = ffjtstringRootArmenian
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootArrows, kn) {
						currentKey = ffjtstringRootArrows
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'B':

					if bytes.Equal(ffjKeystringRootBengali, kn) {
						currentKey = ffjtstringRootBengali
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootBopomofo, kn) {
						currentKey = ffjtstringRootBopomofo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootBoxDrawing, kn) {
						currentKey = ffjtstringRootBoxDrawing
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'C':

					if bytes.Equal(ffjKeystringRootCJKCompatibility, kn) {
						currentKey = ffjtstringRootCJKCompatibility
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootCJKCompatibilityForms, kn) {
						currentKey = ffjtstringRootCJKCompatibilityForms
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootCJKCompatibilityIdeographs, kn) {
						currentKey = ffjtstringRootCJKCompatibilityIdeographs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootCJKSymbolsAndPunctuation, kn) {
						currentKey = ffjtstringRootCJKSymbolsAndPunctuation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootCJKUnifiedIdeographs, kn) {
						currentKey = ffjtstringRootCJKUnifiedIdeographs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootCJKUnifiedIdeographsExtensionA, kn) {
						currentKey = ffjtstringRootCJKUnifiedIdeographsExtensionA
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootCJKUnifiedIdeographsExtensionB, kn) {
						currentKey = ffjtstringRootCJKUnifiedIdeographsExtensionB
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootCherokee, kn) {
						currentKey = ffjtstringRootCherokee
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootCurrencySymbols, kn) {
						currentKey = ffjtstringRootCurrencySymbols
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootCyrillic, kn) {
						currentKey = ffjtstringRootCyrillic
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootCyrillicSupplementary, kn) {
						currentKey = ffjtstringRootCyrillicSupplementary
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'D':

					if bytes.Equal(ffjKeystringRootDevanagari, kn) {
						currentKey = ffjtstringRootDevanagari
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'E':

					if bytes.Equal(ffjKeystringRootEnclosedAlphanumerics, kn) {
						currentKey = ffjtstringRootEnclosedAlphanumerics
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootEnclosedCJKLettersAndMonths, kn) {
						currentKey = ffjtstringRootEnclosedCJKLettersAndMonths
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootEthiopic, kn) {
						currentKey = ffjtstringRootEthiopic
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'G':

					if bytes.Equal(ffjKeystringRootGeometricShapes, kn) {
						currentKey = ffjtstringRootGeometricShapes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootGeorgian, kn) {
						currentKey = ffjtstringRootGeorgian
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootGreekAndCoptic, kn) {
						currentKey = ffjtstringRootGreekAndCoptic
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootGujarati, kn) {
						currentKey = ffjtstringRootGujarati
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootGurmukhi, kn) {
						currentKey = ffjtstringRootGurmukhi
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'H':

					if bytes.Equal(ffjKeystringRootHangulCompatibilityJamo, kn) {
						currentKey = ffjtstringRootHangulCompatibilityJamo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootHangulJamo, kn) {
						currentKey = ffjtstringRootHangulJamo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootHangulSyllables, kn) {
						currentKey = ffjtstringRootHangulSyllables
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootHebrew, kn) {
						currentKey = ffjtstringRootHebrew
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootHiragana, kn) {
						currentKey = ffjtstringRootHiragana
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'I':

					if bytes.Equal(ffjKeystringRootIPAExtentions, kn) {
						currentKey = ffjtstringRootIPAExtentions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'K':

					if bytes.Equal(ffjKeystringRootKangxiRadicals, kn) {
						currentKey = ffjtstringRootKangxiRadicals
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootKatakana, kn) {
						currentKey = ffjtstringRootKatakana
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootKhmer, kn) {
						currentKey = ffjtstringRootKhmer
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootKhmerSymbols, kn) {
						currentKey = ffjtstringRootKhmerSymbols
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'L':

					if bytes.Equal(ffjKeystringRootLatin, kn) {
						currentKey = ffjtstringRootLatin
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootLatinExtendedAdditional, kn) {
						currentKey = ffjtstringRootLatinExtendedAdditional
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootLatin1Supplement, kn) {
						currentKey = ffjtstringRootLatin1Supplement
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootLatinExtendedA, kn) {
						currentKey = ffjtstringRootLatinExtendedA
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootLatinExtendedB, kn) {
						currentKey = ffjtstringRootLatinExtendedB
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootLetterlikeSymbols, kn) {
						currentKey = ffjtstringRootLetterlikeSymbols
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffjKeystringRootMalayalam, kn) {
						currentKey = ffjtstringRootMalayalam
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootMathematicalAlphanumericSymbols, kn) {
						currentKey = ffjtstringRootMathematicalAlphanumericSymbols
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootMathematicalOperators, kn) {
						currentKey = ffjtstringRootMathematicalOperators
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootMiscellaneousSymbols, kn) {
						currentKey = ffjtstringRootMiscellaneousSymbols
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootMongolian, kn) {
						currentKey = ffjtstringRootMongolian
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'N':

					if bytes.Equal(ffjKeystringRootNumberForms, kn) {
						currentKey = ffjtstringRootNumberForms
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'O':

					if bytes.Equal(ffjKeystringRootOriya, kn) {
						currentKey = ffjtstringRootOriya
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffjKeystringRootPhoneticExtensions, kn) {
						currentKey = ffjtstringRootPhoneticExtensions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeystringRootSupplementalArrowsB, kn) {
						currentKey = ffjtstringRootSupplementalArrowsB
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootSyriac, kn) {
						currentKey = ffjtstringRootSyriac
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffjKeystringRootTamil, kn) {
						currentKey = ffjtstringRootTamil
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootThaana, kn) {
						currentKey = ffjtstringRootThaana
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootThai, kn) {
						currentKey = ffjtstringRootThai
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffjKeystringRootUnifiedCanadianAboriginalSyllabics, kn) {
						currentKey = ffjtstringRootUnifiedCanadianAboriginalSyllabics
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'Y':

					if bytes.Equal(ffjKeystringRootYiRadicals, kn) {
						currentKey = ffjtstringRootYiRadicals
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeystringRootYiSyllables, kn) {
						currentKey = ffjtstringRootYiSyllables
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeystringRootYiSyllables, kn) {
					currentKey = ffjtstringRootYiSyllables
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootYiRadicals, kn) {
					currentKey = ffjtstringRootYiRadicals
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootUnifiedCanadianAboriginalSyllabics, kn) {
					currentKey = ffjtstringRootUnifiedCanadianAboriginalSyllabics
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootThai, kn) {
					currentKey = ffjtstringRootThai
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootThaana, kn) {
					currentKey = ffjtstringRootThaana
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootTamil, kn) {
					currentKey = ffjtstringRootTamil
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootSyriac, kn) {
					currentKey = ffjtstringRootSyriac
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootSupplementalArrowsB, kn) {
					currentKey = ffjtstringRootSupplementalArrowsB
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootPhoneticExtensions, kn) {
					currentKey = ffjtstringRootPhoneticExtensions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootOriya, kn) {
					currentKey = ffjtstringRootOriya
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootNumberForms, kn) {
					currentKey = ffjtstringRootNumberForms
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootMongolian, kn) {
					currentKey = ffjtstringRootMongolian
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootMiscellaneousSymbols, kn) {
					currentKey = ffjtstringRootMiscellaneousSymbols
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootMathematicalOperators, kn) {
					currentKey = ffjtstringRootMathematicalOperators
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootMathematicalAlphanumericSymbols, kn) {
					currentKey = ffjtstringRootMathematicalAlphanumericSymbols
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootMalayalam, kn) {
					currentKey = ffjtstringRootMalayalam
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootLetterlikeSymbols, kn) {
					currentKey = ffjtstringRootLetterlikeSymbols
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeystringRootLatinExtendedB, kn) {
					currentKey = ffjtstringRootLatinExtendedB
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeystringRootLatinExtendedA, kn) {
					currentKey = ffjtstringRootLatinExtendedA
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootLatin1Supplement, kn) {
					currentKey = ffjtstringRootLatin1Supplement
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeystringRootLatinExtendedAdditional, kn) {
					currentKey = ffjtstringRootLatinExtendedAdditional
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootLatin, kn) {
					currentKey = ffjtstringRootLatin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootKhmerSymbols, kn) {
					currentKey = ffjtstringRootKhmerSymbols
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootKhmer, kn) {
					currentKey = ffjtstringRootKhmer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootKatakana, kn) {
					currentKey = ffjtstringRootKatakana
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootKangxiRadicals, kn) {
					currentKey = ffjtstringRootKangxiRadicals
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootIPAExtentions, kn) {
					currentKey = ffjtstringRootIPAExtentions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootHiragana, kn) {
					currentKey = ffjtstringRootHiragana
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootHebrew, kn) {
					currentKey = ffjtstringRootHebrew
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootHangulSyllables, kn) {
					currentKey = ffjtstringRootHangulSyllables
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeystringRootHangulJamo, kn) {
					currentKey = ffjtstringRootHangulJamo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeystringRootHangulCompatibilityJamo, kn) {
					currentKey = ffjtstringRootHangulCompatibilityJamo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootGurmukhi, kn) {
					currentKey = ffjtstringRootGurmukhi
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootGujarati, kn) {
					currentKey = ffjtstringRootGujarati
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootGreekAndCoptic, kn) {
					currentKey = ffjtstringRootGreekAndCoptic
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootGeorgian, kn) {
					currentKey = ffjtstringRootGeorgian
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootGeometricShapes, kn) {
					currentKey = ffjtstringRootGeometricShapes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootEthiopic, kn) {
					currentKey = ffjtstringRootEthiopic
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootEnclosedCJKLettersAndMonths, kn) {
					currentKey = ffjtstringRootEnclosedCJKLettersAndMonths
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootEnclosedAlphanumerics, kn) {
					currentKey = ffjtstringRootEnclosedAlphanumerics
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootDevanagari, kn) {
					currentKey = ffjtstringRootDevanagari
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootCyrillicSupplementary, kn) {
					currentKey = ffjtstringRootCyrillicSupplementary
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootCyrillic, kn) {
					currentKey = ffjtstringRootCyrillic
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootCurrencySymbols, kn) {
					currentKey = ffjtstringRootCurrencySymbols
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootCherokee, kn) {
					currentKey = ffjtstringRootCherokee
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootCJKUnifiedIdeographsExtensionB, kn) {
					currentKey = ffjtstringRootCJKUnifiedIdeographsExtensionB
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootCJKUnifiedIdeographsExtensionA, kn) {
					currentKey = ffjtstringRootCJKUnifiedIdeographsExtensionA
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootCJKUnifiedIdeographs, kn) {
					currentKey = ffjtstringRootCJKUnifiedIdeographs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootCJKSymbolsAndPunctuation, kn) {
					currentKey = ffjtstringRootCJKSymbolsAndPunctuation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootCJKCompatibilityIdeographs, kn) {
					currentKey = ffjtstringRootCJKCompatibilityIdeographs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootCJKCompatibilityForms, kn) {
					currentKey = ffjtstringRootCJKCompatibilityForms
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootCJKCompatibility, kn) {
					currentKey = ffjtstringRootCJKCompatibility
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeystringRootBoxDrawing, kn) {
					currentKey = ffjtstringRootBoxDrawing
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootBopomofo, kn) {
					currentKey = ffjtstringRootBopomofo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootBengali, kn) {
					currentKey = ffjtstringRootBengali
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootArrows, kn) {
					currentKey = ffjtstringRootArrows
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootArmenian, kn) {
					currentKey = ffjtstringRootArmenian
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootArabicPresentationFormsB, kn) {
					currentKey = ffjtstringRootArabicPresentationFormsB
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeystringRootArabicPresentationFormsA, kn) {
					currentKey = ffjtstringRootArabicPresentationFormsA
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeystringRootArabic, kn) {
					currentKey = ffjtstringRootArabic
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtstringRootnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtstringRootArabic:
					goto handle_Arabic

				case ffjtstringRootArabicPresentationFormsA:
					goto handle_ArabicPresentationFormsA

				case ffjtstringRootArabicPresentationFormsB:
					goto handle_ArabicPresentationFormsB

				case ffjtstringRootArmenian:
					goto handle_Armenian

				case ffjtstringRootArrows:
					goto handle_Arrows

				case ffjtstringRootBengali:
					goto handle_Bengali

				case ffjtstringRootBopomofo:
					goto handle_Bopomofo

				case ffjtstringRootBoxDrawing:
					goto handle_BoxDrawing

				case ffjtstringRootCJKCompatibility:
					goto handle_CJKCompatibility

				case ffjtstringRootCJKCompatibilityForms:
					goto handle_CJKCompatibilityForms

				case ffjtstringRootCJKCompatibilityIdeographs:
					goto handle_CJKCompatibilityIdeographs

				case ffjtstringRootCJKSymbolsAndPunctuation:
					goto handle_CJKSymbolsAndPunctuation

				case ffjtstringRootCJKUnifiedIdeographs:
					goto handle_CJKUnifiedIdeographs

				case ffjtstringRootCJKUnifiedIdeographsExtensionA:
					goto handle_CJKUnifiedIdeographsExtensionA

				case ffjtstringRootCJKUnifiedIdeographsExtensionB:
					goto handle_CJKUnifiedIdeographsExtensionB

				case ffjtstringRootCherokee:
					goto handle_Cherokee

				case ffjtstringRootCurrencySymbols:
					goto handle_CurrencySymbols

				case ffjtstringRootCyrillic:
					goto handle_Cyrillic

				case ffjtstringRootCyrillicSupplementary:
					goto handle_CyrillicSupplementary

				case ffjtstringRootDevanagari:
					goto handle_Devanagari

				case ffjtstringRootEnclosedAlphanumerics:
					goto handle_EnclosedAlphanumerics

				case ffjtstringRootEnclosedCJKLettersAndMonths:
					goto handle_EnclosedCJKLettersAndMonths

				case ffjtstringRootEthiopic:
					goto handle_Ethiopic

				case ffjtstringRootGeometricShapes:
					goto handle_GeometricShapes

				case ffjtstringRootGeorgian:
					goto handle_Georgian

				case ffjtstringRootGreekAndCoptic:
					goto handle_GreekAndCoptic

				case ffjtstringRootGujarati:
					goto handle_Gujarati

				case ffjtstringRootGurmukhi:
					goto handle_Gurmukhi

				case ffjtstringRootHangulCompatibilityJamo:
					goto handle_HangulCompatibilityJamo

				case ffjtstringRootHangulJamo:
					goto handle_HangulJamo

				case ffjtstringRootHangulSyllables:
					goto handle_HangulSyllables

				case ffjtstringRootHebrew:
					goto handle_Hebrew

				case ffjtstringRootHiragana:
					goto handle_Hiragana

				case ffjtstringRootIPAExtentions:
					goto handle_IPAExtentions

				case ffjtstringRootKangxiRadicals:
					goto handle_KangxiRadicals

				case ffjtstringRootKatakana:
					goto handle_Katakana

				case ffjtstringRootKhmer:
					goto handle_Khmer

				case ffjtstringRootKhmerSymbols:
					goto handle_KhmerSymbols

				case ffjtstringRootLatin:
					goto handle_Latin

				case ffjtstringRootLatinExtendedAdditional:
					goto handle_LatinExtendedAdditional

				case ffjtstringRootLatin1Supplement:
					goto handle_Latin1Supplement

				case ffjtstringRootLatinExtendedA:
					goto handle_LatinExtendedA

				case ffjtstringRootLatinExtendedB:
					goto handle_LatinExtendedB

				case ffjtstringRootLetterlikeSymbols:
					goto handle_LetterlikeSymbols

				case ffjtstringRootMalayalam:
					goto handle_Malayalam

				case ffjtstringRootMathematicalAlphanumericSymbols:
					goto handle_MathematicalAlphanumericSymbols

				case ffjtstringRootMathematicalOperators:
					goto handle_MathematicalOperators

				case ffjtstringRootMiscellaneousSymbols:
					goto handle_MiscellaneousSymbols

				case ffjtstringRootMongolian:
					goto handle_Mongolian

				case ffjtstringRootNumberForms:
					goto handle_NumberForms

				case ffjtstringRootOriya:
					goto handle_Oriya

				case ffjtstringRootPhoneticExtensions:
					goto handle_PhoneticExtensions

				case ffjtstringRootSupplementalArrowsB:
					goto handle_SupplementalArrowsB

				case ffjtstringRootSyriac:
					goto handle_Syriac

				case ffjtstringRootTamil:
					goto handle_Tamil

				case ffjtstringRootThaana:
					goto handle_Thaana

				case ffjtstringRootThai:
					goto handle_Thai

				case ffjtstringRootUnifiedCanadianAboriginalSyllabics:
					goto handle_UnifiedCanadianAboriginalSyllabics

				case ffjtstringRootYiRadicals:
					goto handle_YiRadicals

				case ffjtstringRootYiSyllables:
					goto handle_YiSyllables

				case ffjtstringRootnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Arabic:

	/* handler: j.Arabic type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Arabic = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ArabicPresentationFormsA:

	/* handler: j.ArabicPresentationFormsA type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ArabicPresentationFormsA = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ArabicPresentationFormsB:

	/* handler: j.ArabicPresentationFormsB type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ArabicPresentationFormsB = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Armenian:

	/* handler: j.Armenian type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Armenian = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Arrows:

	/* handler: j.Arrows type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Arrows = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bengali:

	/* handler: j.Bengali type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Bengali = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bopomofo:

	/* handler: j.Bopomofo type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Bopomofo = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BoxDrawing:

	/* handler: j.BoxDrawing type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BoxDrawing = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CJKCompatibility:

	/* handler: j.CJKCompatibility type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CJKCompatibility = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CJKCompatibilityForms:

	/* handler: j.CJKCompatibilityForms type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CJKCompatibilityForms = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CJKCompatibilityIdeographs:

	/* handler: j.CJKCompatibilityIdeographs type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CJKCompatibilityIdeographs = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CJKSymbolsAndPunctuation:

	/* handler: j.CJKSymbolsAndPunctuation type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CJKSymbolsAndPunctuation = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CJKUnifiedIdeographs:

	/* handler: j.CJKUnifiedIdeographs type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CJKUnifiedIdeographs = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CJKUnifiedIdeographsExtensionA:

	/* handler: j.CJKUnifiedIdeographsExtensionA type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CJKUnifiedIdeographsExtensionA = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CJKUnifiedIdeographsExtensionB:

	/* handler: j.CJKUnifiedIdeographsExtensionB type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CJKUnifiedIdeographsExtensionB = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cherokee:

	/* handler: j.Cherokee type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Cherokee = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrencySymbols:

	/* handler: j.CurrencySymbols type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CurrencySymbols = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cyrillic:

	/* handler: j.Cyrillic type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Cyrillic = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CyrillicSupplementary:

	/* handler: j.CyrillicSupplementary type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CyrillicSupplementary = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Devanagari:

	/* handler: j.Devanagari type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Devanagari = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EnclosedAlphanumerics:

	/* handler: j.EnclosedAlphanumerics type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.EnclosedAlphanumerics = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EnclosedCJKLettersAndMonths:

	/* handler: j.EnclosedCJKLettersAndMonths type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.EnclosedCJKLettersAndMonths = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ethiopic:

	/* handler: j.Ethiopic type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Ethiopic = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GeometricShapes:

	/* handler: j.GeometricShapes type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.GeometricShapes = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Georgian:

	/* handler: j.Georgian type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Georgian = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GreekAndCoptic:

	/* handler: j.GreekAndCoptic type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.GreekAndCoptic = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gujarati:

	/* handler: j.Gujarati type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Gujarati = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gurmukhi:

	/* handler: j.Gurmukhi type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Gurmukhi = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HangulCompatibilityJamo:

	/* handler: j.HangulCompatibilityJamo type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.HangulCompatibilityJamo = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HangulJamo:

	/* handler: j.HangulJamo type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.HangulJamo = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HangulSyllables:

	/* handler: j.HangulSyllables type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.HangulSyllables = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hebrew:

	/* handler: j.Hebrew type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Hebrew = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hiragana:

	/* handler: j.Hiragana type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Hiragana = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IPAExtentions:

	/* handler: j.IPAExtentions type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.IPAExtentions = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_KangxiRadicals:

	/* handler: j.KangxiRadicals type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.KangxiRadicals = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Katakana:

	/* handler: j.Katakana type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Katakana = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Khmer:

	/* handler: j.Khmer type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Khmer = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_KhmerSymbols:

	/* handler: j.KhmerSymbols type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.KhmerSymbols = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Latin:

	/* handler: j.Latin type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Latin = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LatinExtendedAdditional:

	/* handler: j.LatinExtendedAdditional type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LatinExtendedAdditional = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Latin1Supplement:

	/* handler: j.Latin1Supplement type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Latin1Supplement = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LatinExtendedA:

	/* handler: j.LatinExtendedA type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LatinExtendedA = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LatinExtendedB:

	/* handler: j.LatinExtendedB type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LatinExtendedB = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LetterlikeSymbols:

	/* handler: j.LetterlikeSymbols type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LetterlikeSymbols = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Malayalam:

	/* handler: j.Malayalam type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Malayalam = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MathematicalAlphanumericSymbols:

	/* handler: j.MathematicalAlphanumericSymbols type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MathematicalAlphanumericSymbols = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MathematicalOperators:

	/* handler: j.MathematicalOperators type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MathematicalOperators = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MiscellaneousSymbols:

	/* handler: j.MiscellaneousSymbols type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MiscellaneousSymbols = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mongolian:

	/* handler: j.Mongolian type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mongolian = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NumberForms:

	/* handler: j.NumberForms type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.NumberForms = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oriya:

	/* handler: j.Oriya type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Oriya = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhoneticExtensions:

	/* handler: j.PhoneticExtensions type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhoneticExtensions = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SupplementalArrowsB:

	/* handler: j.SupplementalArrowsB type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SupplementalArrowsB = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Syriac:

	/* handler: j.Syriac type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Syriac = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tamil:

	/* handler: j.Tamil type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Tamil = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thaana:

	/* handler: j.Thaana type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Thaana = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thai:

	/* handler: j.Thai type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Thai = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UnifiedCanadianAboriginalSyllabics:

	/* handler: j.UnifiedCanadianAboriginalSyllabics type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.UnifiedCanadianAboriginalSyllabics = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_YiRadicals:

	/* handler: j.YiRadicals type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.YiRadicals = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_YiSyllables:

	/* handler: j.YiSyllables type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.YiSyllables = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *syntheaAddress) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"city":`)
	fflib.WriteJsonString(buf, string(j.City))
	buf.WriteString(`,"country":`)
	fflib.WriteJsonString(buf, string(j.Country))
	buf.WriteString(`,"extension":`)
	if j.Extension != nil {
		buf.WriteString(`[`)
		for i, v := range j.Extension {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"line":`)
	if j.Line != nil {
		buf.WriteString(`[`)
		for i, v := range j.Line {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"postalCode":`)
	fflib.WriteJsonString(buf, string(j.PostalCode))
	buf.WriteString(`,"state":`)
	fflib.WriteJsonString(buf, string(j.State))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtsyntheaAddressbase = iota
	ffjtsyntheaAddressnosuchkey

	ffjtsyntheaAddressCity

	ffjtsyntheaAddressCountry

	ffjtsyntheaAddressExtension

	ffjtsyntheaAddressLine

	ffjtsyntheaAddressPostalCode

	ffjtsyntheaAddressState
)

var ffjKeysyntheaAddressCity = []byte("city")

var ffjKeysyntheaAddressCountry = []byte("country")

var ffjKeysyntheaAddressExtension = []byte("extension")

var ffjKeysyntheaAddressLine = []byte("line")

var ffjKeysyntheaAddressPostalCode = []byte("postalCode")

var ffjKeysyntheaAddressState = []byte("state")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *syntheaAddress) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtsyntheaAddressbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtsyntheaAddressnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeysyntheaAddressCity, kn) {
						currentKey = ffjtsyntheaAddressCity
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeysyntheaAddressCountry, kn) {
						currentKey = ffjtsyntheaAddressCountry
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeysyntheaAddressExtension, kn) {
						currentKey = ffjtsyntheaAddressExtension
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeysyntheaAddressLine, kn) {
						currentKey = ffjtsyntheaAddressLine
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeysyntheaAddressPostalCode, kn) {
						currentKey = ffjtsyntheaAddressPostalCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeysyntheaAddressState, kn) {
						currentKey = ffjtsyntheaAddressState
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeysyntheaAddressState, kn) {
					currentKey = ffjtsyntheaAddressState
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeysyntheaAddressPostalCode, kn) {
					currentKey = ffjtsyntheaAddressPostalCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaAddressLine, kn) {
					currentKey = ffjtsyntheaAddressLine
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeysyntheaAddressExtension, kn) {
					currentKey = ffjtsyntheaAddressExtension
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaAddressCountry, kn) {
					currentKey = ffjtsyntheaAddressCountry
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaAddressCity, kn) {
					currentKey = ffjtsyntheaAddressCity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtsyntheaAddressnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtsyntheaAddressCity:
					goto handle_City

				case ffjtsyntheaAddressCountry:
					goto handle_Country

				case ffjtsyntheaAddressExtension:
					goto handle_Extension

				case ffjtsyntheaAddressLine:
					goto handle_Line

				case ffjtsyntheaAddressPostalCode:
					goto handle_PostalCode

				case ffjtsyntheaAddressState:
					goto handle_State

				case ffjtsyntheaAddressnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_City:

	/* handler: j.City type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.City = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Country:

	/* handler: j.Country type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Country = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Extension:

	/* handler: j.Extension type=[]tmp.syntheaExtension kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Extension = nil
		} else {

			j.Extension = []syntheaExtension{}

			wantVal := true

			for {

				var tmpJExtension syntheaExtension

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJExtension type=tmp.syntheaExtension kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJExtension.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Extension = append(j.Extension, tmpJExtension)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Line:

	/* handler: j.Line type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Line = nil
		} else {

			j.Line = []string{}

			wantVal := true

			for {

				var tmpJLine string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJLine type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJLine = string(string(outBuf))

					}
				}

				j.Line = append(j.Line, tmpJLine)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PostalCode:

	/* handler: j.PostalCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PostalCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_State:

	/* handler: j.State type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.State = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *syntheaCode) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"coding":`)
	if j.Coding != nil {
		buf.WriteString(`[`)
		for i, v := range j.Coding {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"text":`)
	fflib.WriteJsonString(buf, string(j.Text))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtsyntheaCodebase = iota
	ffjtsyntheaCodenosuchkey

	ffjtsyntheaCodeCoding

	ffjtsyntheaCodeText
)

var ffjKeysyntheaCodeCoding = []byte("coding")

var ffjKeysyntheaCodeText = []byte("text")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *syntheaCode) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtsyntheaCodebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtsyntheaCodenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeysyntheaCodeCoding, kn) {
						currentKey = ffjtsyntheaCodeCoding
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeysyntheaCodeText, kn) {
						currentKey = ffjtsyntheaCodeText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaCodeText, kn) {
					currentKey = ffjtsyntheaCodeText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaCodeCoding, kn) {
					currentKey = ffjtsyntheaCodeCoding
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtsyntheaCodenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtsyntheaCodeCoding:
					goto handle_Coding

				case ffjtsyntheaCodeText:
					goto handle_Text

				case ffjtsyntheaCodenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Coding:

	/* handler: j.Coding type=[]tmp.syntheaCoding kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Coding = nil
		} else {

			j.Coding = []syntheaCoding{}

			wantVal := true

			for {

				var tmpJCoding syntheaCoding

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJCoding type=tmp.syntheaCoding kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJCoding.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Coding = append(j.Coding, tmpJCoding)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *syntheaCoding) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.WriteJsonString(buf, string(j.Code))
	buf.WriteString(`,"display":`)
	fflib.WriteJsonString(buf, string(j.Display))
	buf.WriteString(`,"system":`)
	fflib.WriteJsonString(buf, string(j.System))
	buf.WriteString(`,"unit":`)
	fflib.WriteJsonString(buf, string(j.Unit))
	buf.WriteString(`,"value":`)
	fflib.AppendFloat(buf, float64(j.Value), 'g', -1, 64)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtsyntheaCodingbase = iota
	ffjtsyntheaCodingnosuchkey

	ffjtsyntheaCodingCode

	ffjtsyntheaCodingDisplay

	ffjtsyntheaCodingSystem

	ffjtsyntheaCodingUnit

	ffjtsyntheaCodingValue
)

var ffjKeysyntheaCodingCode = []byte("code")

var ffjKeysyntheaCodingDisplay = []byte("display")

var ffjKeysyntheaCodingSystem = []byte("system")

var ffjKeysyntheaCodingUnit = []byte("unit")

var ffjKeysyntheaCodingValue = []byte("value")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *syntheaCoding) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtsyntheaCodingbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtsyntheaCodingnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeysyntheaCodingCode, kn) {
						currentKey = ffjtsyntheaCodingCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeysyntheaCodingDisplay, kn) {
						currentKey = ffjtsyntheaCodingDisplay
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeysyntheaCodingSystem, kn) {
						currentKey = ffjtsyntheaCodingSystem
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeysyntheaCodingUnit, kn) {
						currentKey = ffjtsyntheaCodingUnit
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeysyntheaCodingValue, kn) {
						currentKey = ffjtsyntheaCodingValue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaCodingValue, kn) {
					currentKey = ffjtsyntheaCodingValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaCodingUnit, kn) {
					currentKey = ffjtsyntheaCodingUnit
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeysyntheaCodingSystem, kn) {
					currentKey = ffjtsyntheaCodingSystem
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeysyntheaCodingDisplay, kn) {
					currentKey = ffjtsyntheaCodingDisplay
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaCodingCode, kn) {
					currentKey = ffjtsyntheaCodingCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtsyntheaCodingnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtsyntheaCodingCode:
					goto handle_Code

				case ffjtsyntheaCodingDisplay:
					goto handle_Display

				case ffjtsyntheaCodingSystem:
					goto handle_System

				case ffjtsyntheaCodingUnit:
					goto handle_Unit

				case ffjtsyntheaCodingValue:
					goto handle_Value

				case ffjtsyntheaCodingnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: j.Code type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Code = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Display:

	/* handler: j.Display type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Display = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_System:

	/* handler: j.System type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.System = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unit:

	/* handler: j.Unit type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Unit = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Value:

	/* handler: j.Value type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Value = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *syntheaCurrency) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"currency":`)
	fflib.WriteJsonString(buf, string(j.Currency))
	buf.WriteString(`,"value":`)
	fflib.AppendFloat(buf, float64(j.Value), 'g', -1, 64)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtsyntheaCurrencybase = iota
	ffjtsyntheaCurrencynosuchkey

	ffjtsyntheaCurrencyCurrency

	ffjtsyntheaCurrencyValue
)

var ffjKeysyntheaCurrencyCurrency = []byte("currency")

var ffjKeysyntheaCurrencyValue = []byte("value")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *syntheaCurrency) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtsyntheaCurrencybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtsyntheaCurrencynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeysyntheaCurrencyCurrency, kn) {
						currentKey = ffjtsyntheaCurrencyCurrency
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeysyntheaCurrencyValue, kn) {
						currentKey = ffjtsyntheaCurrencyValue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaCurrencyValue, kn) {
					currentKey = ffjtsyntheaCurrencyValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaCurrencyCurrency, kn) {
					currentKey = ffjtsyntheaCurrencyCurrency
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtsyntheaCurrencynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtsyntheaCurrencyCurrency:
					goto handle_Currency

				case ffjtsyntheaCurrencyValue:
					goto handle_Value

				case ffjtsyntheaCurrencynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Currency:

	/* handler: j.Currency type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Currency = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Value:

	/* handler: j.Value type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Value = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *syntheaExtension) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"url":`)
	fflib.WriteJsonString(buf, string(j.URL))
	buf.WriteString(`,"valueAddress":`)

	{

		err = j.ValueAddress.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"valueCode":`)
	fflib.WriteJsonString(buf, string(j.ValueCode))
	buf.WriteString(`,"valueDecimal":`)
	fflib.AppendFloat(buf, float64(j.ValueDecimal), 'g', -1, 64)
	buf.WriteString(`,"valueString":`)
	fflib.WriteJsonString(buf, string(j.ValueString))
	buf.WriteString(`,"extension":`)
	if j.Extension != nil {
		buf.WriteString(`[`)
		for i, v := range j.Extension {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtsyntheaExtensionbase = iota
	ffjtsyntheaExtensionnosuchkey

	ffjtsyntheaExtensionURL

	ffjtsyntheaExtensionValueAddress

	ffjtsyntheaExtensionValueCode

	ffjtsyntheaExtensionValueDecimal

	ffjtsyntheaExtensionValueString

	ffjtsyntheaExtensionExtension
)

var ffjKeysyntheaExtensionURL = []byte("url")

var ffjKeysyntheaExtensionValueAddress = []byte("valueAddress")

var ffjKeysyntheaExtensionValueCode = []byte("valueCode")

var ffjKeysyntheaExtensionValueDecimal = []byte("valueDecimal")

var ffjKeysyntheaExtensionValueString = []byte("valueString")

var ffjKeysyntheaExtensionExtension = []byte("extension")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *syntheaExtension) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtsyntheaExtensionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtsyntheaExtensionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffjKeysyntheaExtensionExtension, kn) {
						currentKey = ffjtsyntheaExtensionExtension
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeysyntheaExtensionURL, kn) {
						currentKey = ffjtsyntheaExtensionURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeysyntheaExtensionValueAddress, kn) {
						currentKey = ffjtsyntheaExtensionValueAddress
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeysyntheaExtensionValueCode, kn) {
						currentKey = ffjtsyntheaExtensionValueCode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeysyntheaExtensionValueDecimal, kn) {
						currentKey = ffjtsyntheaExtensionValueDecimal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeysyntheaExtensionValueString, kn) {
						currentKey = ffjtsyntheaExtensionValueString
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeysyntheaExtensionExtension, kn) {
					currentKey = ffjtsyntheaExtensionExtension
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeysyntheaExtensionValueString, kn) {
					currentKey = ffjtsyntheaExtensionValueString
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaExtensionValueDecimal, kn) {
					currentKey = ffjtsyntheaExtensionValueDecimal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaExtensionValueCode, kn) {
					currentKey = ffjtsyntheaExtensionValueCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeysyntheaExtensionValueAddress, kn) {
					currentKey = ffjtsyntheaExtensionValueAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaExtensionURL, kn) {
					currentKey = ffjtsyntheaExtensionURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtsyntheaExtensionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtsyntheaExtensionURL:
					goto handle_URL

				case ffjtsyntheaExtensionValueAddress:
					goto handle_ValueAddress

				case ffjtsyntheaExtensionValueCode:
					goto handle_ValueCode

				case ffjtsyntheaExtensionValueDecimal:
					goto handle_ValueDecimal

				case ffjtsyntheaExtensionValueString:
					goto handle_ValueString

				case ffjtsyntheaExtensionExtension:
					goto handle_Extension

				case ffjtsyntheaExtensionnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ValueAddress:

	/* handler: j.ValueAddress type=tmp.syntheaAddress kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.ValueAddress.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ValueCode:

	/* handler: j.ValueCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ValueCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ValueDecimal:

	/* handler: j.ValueDecimal type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ValueDecimal = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ValueString:

	/* handler: j.ValueString type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ValueString = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Extension:

	/* handler: j.Extension type=[]tmp.syntheaExtension kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Extension = nil
		} else {

			j.Extension = []syntheaExtension{}

			wantVal := true

			for {

				var tmpJExtension syntheaExtension

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJExtension type=tmp.syntheaExtension kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJExtension.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Extension = append(j.Extension, tmpJExtension)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *syntheaRange) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"end":`)

	{

		obj, err = j.End.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"start":`)

	{

		obj, err = j.Start.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtsyntheaRangebase = iota
	ffjtsyntheaRangenosuchkey

	ffjtsyntheaRangeEnd

	ffjtsyntheaRangeStart
)

var ffjKeysyntheaRangeEnd = []byte("end")

var ffjKeysyntheaRangeStart = []byte("start")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *syntheaRange) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtsyntheaRangebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtsyntheaRangenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffjKeysyntheaRangeEnd, kn) {
						currentKey = ffjtsyntheaRangeEnd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeysyntheaRangeStart, kn) {
						currentKey = ffjtsyntheaRangeStart
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeysyntheaRangeStart, kn) {
					currentKey = ffjtsyntheaRangeStart
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaRangeEnd, kn) {
					currentKey = ffjtsyntheaRangeEnd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtsyntheaRangenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtsyntheaRangeEnd:
					goto handle_End

				case ffjtsyntheaRangeStart:
					goto handle_Start

				case ffjtsyntheaRangenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_End:

	/* handler: j.End type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.End.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Start:

	/* handler: j.Start type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Start.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *syntheaReference) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"display":`)
	fflib.WriteJsonString(buf, string(j.Display))
	buf.WriteString(`,"reference":`)
	fflib.WriteJsonString(buf, string(j.Reference))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtsyntheaReferencebase = iota
	ffjtsyntheaReferencenosuchkey

	ffjtsyntheaReferenceDisplay

	ffjtsyntheaReferenceReference
)

var ffjKeysyntheaReferenceDisplay = []byte("display")

var ffjKeysyntheaReferenceReference = []byte("reference")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *syntheaReference) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtsyntheaReferencebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtsyntheaReferencenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeysyntheaReferenceDisplay, kn) {
						currentKey = ffjtsyntheaReferenceDisplay
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeysyntheaReferenceReference, kn) {
						currentKey = ffjtsyntheaReferenceReference
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaReferenceReference, kn) {
					currentKey = ffjtsyntheaReferenceReference
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeysyntheaReferenceDisplay, kn) {
					currentKey = ffjtsyntheaReferenceDisplay
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtsyntheaReferencenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtsyntheaReferenceDisplay:
					goto handle_Display

				case ffjtsyntheaReferenceReference:
					goto handle_Reference

				case ffjtsyntheaReferencenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Display:

	/* handler: j.Display type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Display = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reference:

	/* handler: j.Reference type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Reference = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *syntheaRoot) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"entry":`)
	if j.Entry != nil {
		buf.WriteString(`[`)
		for i, v := range j.Entry {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Inline struct. type=struct { FullURL string "json:\"fullUrl\""; Request *struct { Method string "json:\"method\""; URL string "json:\"url\"" } "json:\"request\""; Resource *struct { AbatementDateTime time.Time "json:\"abatementDateTime\""; AchievementStatus tmp.syntheaCode "json:\"achievementStatus\""; Active bool "json:\"active\""; Activity []struct { Detail *struct { Code tmp.syntheaCode "json:\"code\""; Location tmp.syntheaReference "json:\"location\""; Status string "json:\"status\"" } "json:\"detail\"" } "json:\"activity\""; Address []tmp.syntheaAddress "json:\"address\""; Addresses []tmp.syntheaReference "json:\"addresses\""; AuthoredOn time.Time "json:\"authoredOn\""; BillablePeriod tmp.syntheaRange "json:\"billablePeriod\""; BirthDate string "json:\"birthDate\""; CareTeam []struct { Provider tmp.syntheaReference "json:\"provider\""; Reference string "json:\"reference\""; Role tmp.syntheaCode "json:\"role\""; Sequence int64 "json:\"sequence\"" } "json:\"careTeam\""; Category []tmp.syntheaCode "json:\"category\""; Claim tmp.syntheaReference "json:\"claim\""; Class tmp.syntheaCoding "json:\"class\""; ClinicalStatus tmp.syntheaCode "json:\"clinicalStatus\""; Code tmp.syntheaCode "json:\"code\""; Communication []struct { Language tmp.syntheaCode "json:\"language\"" } "json:\"communication\""; Component []struct { Code tmp.syntheaCode "json:\"code\""; ValueQuantity tmp.syntheaCoding "json:\"valueQuantity\"" } "json:\"component\""; Contained []struct { Beneficiary tmp.syntheaReference "json:\"beneficiary\""; ID string "json:\"id\""; Intent string "json:\"intent\""; Payor []tmp.syntheaReference "json:\"payor\""; Performer []tmp.syntheaReference "json:\"performer\""; Requester tmp.syntheaReference "json:\"requester\""; ResourceType string "json:\"resourceType\""; Status string "json:\"status\""; Subject tmp.syntheaReference "json:\"subject\""; Type tmp.syntheaCode "json:\"type\"" } "json:\"contained\""; Created time.Time "json:\"created\""; DeceasedDateTime time.Time "json:\"deceasedDateTime\""; Description tmp.syntheaCode "json:\"description\""; Diagnosis []struct { DiagnosisReference tmp.syntheaReference "json:\"diagnosisReference\""; Sequence int64 "json:\"sequence\""; Type []tmp.syntheaCode "json:\"type\"" } "json:\"diagnosis\""; DosageInstruction []struct { AsNeededBoolean bool "json:\"asNeededBoolean\""; DoseAndRate []struct { DoseQuantity *struct { Value float64 "json:\"value\"" } "json:\"doseQuantity\""; Type tmp.syntheaCode "json:\"type\"" } "json:\"doseAndRate\""; Sequence int64 "json:\"sequence\""; Timing *struct { Repeat *struct { Frequency int64 "json:\"frequency\""; Period float64 "json:\"period\""; PeriodUnit string "json:\"periodUnit\"" } "json:\"repeat\"" } "json:\"timing\"" } "json:\"dosageInstruction\""; EffectiveDateTime time.Time "json:\"effectiveDateTime\""; Encounter tmp.syntheaReference "json:\"encounter\""; Extension []tmp.syntheaExtension "json:\"extension\""; Gender string "json:\"gender\""; Goal []tmp.syntheaReference "json:\"goal\""; ID string "json:\"id\""; Identifier []struct { System string "json:\"system\""; Type tmp.syntheaCode "json:\"type\""; Use string "json:\"use\""; Value string "json:\"value\"" } "json:\"identifier\""; Insurance []struct { Coverage tmp.syntheaReference "json:\"coverage\""; Focal bool "json:\"focal\""; Sequence int64 "json:\"sequence\"" } "json:\"insurance\""; Insurer tmp.syntheaReference "json:\"insurer\""; Intent string "json:\"intent\""; Issued time.Time "json:\"issued\""; Item []struct { Adjudication []struct { Amount tmp.syntheaCurrency "json:\"amount\""; Category tmp.syntheaCode "json:\"category\"" } "json:\"adjudication\""; Category tmp.syntheaCode "json:\"category\""; DiagnosisSequence []int64 "json:\"diagnosisSequence\""; Encounter []tmp.syntheaReference "json:\"encounter\""; InformationSequence []int64 "json:\"informationSequence\""; LocationCodeableConcept tmp.syntheaCode "json:\"locationCodeableConcept\""; Net tmp.syntheaCurrency "json:\"net\""; ProcedureSequence []int64 "json:\"procedureSequence\""; ProductOrService tmp.syntheaCode "json:\"productOrService\""; Sequence int64 "json:\"sequence\""; ServicedPeriod tmp.syntheaRange "json:\"servicedPeriod\"" } "json:\"item\""; LifecycleStatus string "json:\"lifecycleStatus\""; ManagingOrganization []tmp.syntheaReference "json:\"managingOrganization\""; MaritalStatus tmp.syntheaCode "json:\"maritalStatus\""; MedicationCodeableConcept tmp.syntheaCode "json:\"medicationCodeableConcept\""; MultipleBirthBoolean bool "json:\"multipleBirthBoolean\""; Name jsontext.Value "json:\"name\""; NumberOfInstances int64 "json:\"numberOfInstances\""; NumberOfSeries int64 "json:\"numberOfSeries\""; OccurrenceDateTime time.Time "json:\"occurrenceDateTime\""; OnsetDateTime time.Time "json:\"onsetDateTime\""; Outcome string "json:\"outcome\""; Participant []struct { Individual tmp.syntheaReference "json:\"individual\""; Member tmp.syntheaReference "json:\"member\""; Role []tmp.syntheaCode "json:\"role\"" } "json:\"participant\""; Patient tmp.syntheaReference "json:\"patient\""; Payment *struct { Amount tmp.syntheaCurrency "json:\"amount\"" } "json:\"payment\""; PerformedPeriod tmp.syntheaRange "json:\"performedPeriod\""; Period tmp.syntheaRange "json:\"period\""; Prescription tmp.syntheaReference "json:\"prescription\""; PrimarySource bool "json:\"primarySource\""; Priority tmp.syntheaCode "json:\"priority\""; Procedure []struct { ProcedureReference tmp.syntheaReference "json:\"procedureReference\""; Sequence int64 "json:\"sequence\"" } "json:\"procedure\""; Provider tmp.syntheaReference "json:\"provider\""; ReasonCode []tmp.syntheaCode "json:\"reasonCode\""; ReasonReference []tmp.syntheaReference "json:\"reasonReference\""; RecordedDate time.Time "json:\"recordedDate\""; Referral tmp.syntheaReference "json:\"referral\""; Requester tmp.syntheaReference "json:\"requester\""; ResourceType string "json:\"resourceType\""; Result []tmp.syntheaReference "json:\"result\""; Series []struct { BodySite tmp.syntheaCoding "json:\"bodySite\""; Instance []struct { Number int64 "json:\"number\""; SopClass tmp.syntheaCoding "json:\"sopClass\""; Title string "json:\"title\""; UID string "json:\"uid\"" } "json:\"instance\""; Modality tmp.syntheaCoding "json:\"modality\""; Number int64 "json:\"number\""; NumberOfInstances int64 "json:\"numberOfInstances\""; Started string "json:\"started\""; UID string "json:\"uid\"" } "json:\"series\""; ServiceProvider tmp.syntheaReference "json:\"serviceProvider\""; Started time.Time "json:\"started\""; Status string "json:\"status\""; Subject tmp.syntheaReference "json:\"subject\""; SupportingInfo []struct { Category tmp.syntheaCode "json:\"category\""; Sequence int64 "json:\"sequence\""; ValueReference tmp.syntheaReference "json:\"valueReference\"" } "json:\"supportingInfo\""; Telecom []map[string]string "json:\"telecom\""; Text map[string]string "json:\"text\""; Total jsontext.Value "json:\"total\""; Type jsontext.Value "json:\"type\""; Use string "json:\"use\""; VaccineCode tmp.syntheaCode "json:\"vaccineCode\""; ValueCodeableConcept tmp.syntheaCode "json:\"valueCodeableConcept\""; ValueQuantity tmp.syntheaCoding "json:\"valueQuantity\""; VerificationStatus tmp.syntheaCode "json:\"verificationStatus\"" } "json:\"resource\"" } kind=struct */
			buf.WriteString(`{ "fullUrl":`)
			fflib.WriteJsonString(buf, string(v.FullURL))
			if v.Request != nil {
				/* Inline struct. type=struct { Method string "json:\"method\""; URL string "json:\"url\"" } kind=struct */
				buf.WriteString(`,"request":{ "method":`)
				fflib.WriteJsonString(buf, string(v.Request.Method))
				buf.WriteString(`,"url":`)
				fflib.WriteJsonString(buf, string(v.Request.URL))
				buf.WriteByte('}')
			} else {
				buf.WriteString(`,"request":null`)
			}
			if v.Resource != nil {
				/* Inline struct. type=struct { AbatementDateTime time.Time "json:\"abatementDateTime\""; AchievementStatus tmp.syntheaCode "json:\"achievementStatus\""; Active bool "json:\"active\""; Activity []struct { Detail *struct { Code tmp.syntheaCode "json:\"code\""; Location tmp.syntheaReference "json:\"location\""; Status string "json:\"status\"" } "json:\"detail\"" } "json:\"activity\""; Address []tmp.syntheaAddress "json:\"address\""; Addresses []tmp.syntheaReference "json:\"addresses\""; AuthoredOn time.Time "json:\"authoredOn\""; BillablePeriod tmp.syntheaRange "json:\"billablePeriod\""; BirthDate string "json:\"birthDate\""; CareTeam []struct { Provider tmp.syntheaReference "json:\"provider\""; Reference string "json:\"reference\""; Role tmp.syntheaCode "json:\"role\""; Sequence int64 "json:\"sequence\"" } "json:\"careTeam\""; Category []tmp.syntheaCode "json:\"category\""; Claim tmp.syntheaReference "json:\"claim\""; Class tmp.syntheaCoding "json:\"class\""; ClinicalStatus tmp.syntheaCode "json:\"clinicalStatus\""; Code tmp.syntheaCode "json:\"code\""; Communication []struct { Language tmp.syntheaCode "json:\"language\"" } "json:\"communication\""; Component []struct { Code tmp.syntheaCode "json:\"code\""; ValueQuantity tmp.syntheaCoding "json:\"valueQuantity\"" } "json:\"component\""; Contained []struct { Beneficiary tmp.syntheaReference "json:\"beneficiary\""; ID string "json:\"id\""; Intent string "json:\"intent\""; Payor []tmp.syntheaReference "json:\"payor\""; Performer []tmp.syntheaReference "json:\"performer\""; Requester tmp.syntheaReference "json:\"requester\""; ResourceType string "json:\"resourceType\""; Status string "json:\"status\""; Subject tmp.syntheaReference "json:\"subject\""; Type tmp.syntheaCode "json:\"type\"" } "json:\"contained\""; Created time.Time "json:\"created\""; DeceasedDateTime time.Time "json:\"deceasedDateTime\""; Description tmp.syntheaCode "json:\"description\""; Diagnosis []struct { DiagnosisReference tmp.syntheaReference "json:\"diagnosisReference\""; Sequence int64 "json:\"sequence\""; Type []tmp.syntheaCode "json:\"type\"" } "json:\"diagnosis\""; DosageInstruction []struct { AsNeededBoolean bool "json:\"asNeededBoolean\""; DoseAndRate []struct { DoseQuantity *struct { Value float64 "json:\"value\"" } "json:\"doseQuantity\""; Type tmp.syntheaCode "json:\"type\"" } "json:\"doseAndRate\""; Sequence int64 "json:\"sequence\""; Timing *struct { Repeat *struct { Frequency int64 "json:\"frequency\""; Period float64 "json:\"period\""; PeriodUnit string "json:\"periodUnit\"" } "json:\"repeat\"" } "json:\"timing\"" } "json:\"dosageInstruction\""; EffectiveDateTime time.Time "json:\"effectiveDateTime\""; Encounter tmp.syntheaReference "json:\"encounter\""; Extension []tmp.syntheaExtension "json:\"extension\""; Gender string "json:\"gender\""; Goal []tmp.syntheaReference "json:\"goal\""; ID string "json:\"id\""; Identifier []struct { System string "json:\"system\""; Type tmp.syntheaCode "json:\"type\""; Use string "json:\"use\""; Value string "json:\"value\"" } "json:\"identifier\""; Insurance []struct { Coverage tmp.syntheaReference "json:\"coverage\""; Focal bool "json:\"focal\""; Sequence int64 "json:\"sequence\"" } "json:\"insurance\""; Insurer tmp.syntheaReference "json:\"insurer\""; Intent string "json:\"intent\""; Issued time.Time "json:\"issued\""; Item []struct { Adjudication []struct { Amount tmp.syntheaCurrency "json:\"amount\""; Category tmp.syntheaCode "json:\"category\"" } "json:\"adjudication\""; Category tmp.syntheaCode "json:\"category\""; DiagnosisSequence []int64 "json:\"diagnosisSequence\""; Encounter []tmp.syntheaReference "json:\"encounter\""; InformationSequence []int64 "json:\"informationSequence\""; LocationCodeableConcept tmp.syntheaCode "json:\"locationCodeableConcept\""; Net tmp.syntheaCurrency "json:\"net\""; ProcedureSequence []int64 "json:\"procedureSequence\""; ProductOrService tmp.syntheaCode "json:\"productOrService\""; Sequence int64 "json:\"sequence\""; ServicedPeriod tmp.syntheaRange "json:\"servicedPeriod\"" } "json:\"item\""; LifecycleStatus string "json:\"lifecycleStatus\""; ManagingOrganization []tmp.syntheaReference "json:\"managingOrganization\""; MaritalStatus tmp.syntheaCode "json:\"maritalStatus\""; MedicationCodeableConcept tmp.syntheaCode "json:\"medicationCodeableConcept\""; MultipleBirthBoolean bool "json:\"multipleBirthBoolean\""; Name jsontext.Value "json:\"name\""; NumberOfInstances int64 "json:\"numberOfInstances\""; NumberOfSeries int64 "json:\"numberOfSeries\""; OccurrenceDateTime time.Time "json:\"occurrenceDateTime\""; OnsetDateTime time.Time "json:\"onsetDateTime\""; Outcome string "json:\"outcome\""; Participant []struct { Individual tmp.syntheaReference "json:\"individual\""; Member tmp.syntheaReference "json:\"member\""; Role []tmp.syntheaCode "json:\"role\"" } "json:\"participant\""; Patient tmp.syntheaReference "json:\"patient\""; Payment *struct { Amount tmp.syntheaCurrency "json:\"amount\"" } "json:\"payment\""; PerformedPeriod tmp.syntheaRange "json:\"performedPeriod\""; Period tmp.syntheaRange "json:\"period\""; Prescription tmp.syntheaReference "json:\"prescription\""; PrimarySource bool "json:\"primarySource\""; Priority tmp.syntheaCode "json:\"priority\""; Procedure []struct { ProcedureReference tmp.syntheaReference "json:\"procedureReference\""; Sequence int64 "json:\"sequence\"" } "json:\"procedure\""; Provider tmp.syntheaReference "json:\"provider\""; ReasonCode []tmp.syntheaCode "json:\"reasonCode\""; ReasonReference []tmp.syntheaReference "json:\"reasonReference\""; RecordedDate time.Time "json:\"recordedDate\""; Referral tmp.syntheaReference "json:\"referral\""; Requester tmp.syntheaReference "json:\"requester\""; ResourceType string "json:\"resourceType\""; Result []tmp.syntheaReference "json:\"result\""; Series []struct { BodySite tmp.syntheaCoding "json:\"bodySite\""; Instance []struct { Number int64 "json:\"number\""; SopClass tmp.syntheaCoding "json:\"sopClass\""; Title string "json:\"title\""; UID string "json:\"uid\"" } "json:\"instance\""; Modality tmp.syntheaCoding "json:\"modality\""; Number int64 "json:\"number\""; NumberOfInstances int64 "json:\"numberOfInstances\""; Started string "json:\"started\""; UID string "json:\"uid\"" } "json:\"series\""; ServiceProvider tmp.syntheaReference "json:\"serviceProvider\""; Started time.Time "json:\"started\""; Status string "json:\"status\""; Subject tmp.syntheaReference "json:\"subject\""; SupportingInfo []struct { Category tmp.syntheaCode "json:\"category\""; Sequence int64 "json:\"sequence\""; ValueReference tmp.syntheaReference "json:\"valueReference\"" } "json:\"supportingInfo\""; Telecom []map[string]string "json:\"telecom\""; Text map[string]string "json:\"text\""; Total jsontext.Value "json:\"total\""; Type jsontext.Value "json:\"type\""; Use string "json:\"use\""; VaccineCode tmp.syntheaCode "json:\"vaccineCode\""; ValueCodeableConcept tmp.syntheaCode "json:\"valueCodeableConcept\""; ValueQuantity tmp.syntheaCoding "json:\"valueQuantity\""; VerificationStatus tmp.syntheaCode "json:\"verificationStatus\"" } kind=struct */
				buf.WriteString(`,"resource":{ "abatementDateTime":`)

				{

					obj, err = v.Resource.AbatementDateTime.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
				buf.WriteString(`,"achievementStatus":`)

				{

					err = v.Resource.AchievementStatus.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				if v.Resource.Active {
					buf.WriteString(`,"active":true`)
				} else {
					buf.WriteString(`,"active":false`)
				}
				buf.WriteString(`,"activity":`)
				if v.Resource.Activity != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Activity {
						if i != 0 {
							buf.WriteString(`,`)
						}
						/* Inline struct. type=struct { Detail *struct { Code tmp.syntheaCode "json:\"code\""; Location tmp.syntheaReference "json:\"location\""; Status string "json:\"status\"" } "json:\"detail\"" } kind=struct */
						if v.Detail != nil {
							/* Inline struct. type=struct { Code tmp.syntheaCode "json:\"code\""; Location tmp.syntheaReference "json:\"location\""; Status string "json:\"status\"" } kind=struct */
							buf.WriteString(`{ "detail":{ "code":`)

							{

								err = v.Detail.Code.MarshalJSONBuf(buf)
								if err != nil {
									return err
								}

							}
							buf.WriteString(`,"location":`)

							{

								err = v.Detail.Location.MarshalJSONBuf(buf)
								if err != nil {
									return err
								}

							}
							buf.WriteString(`,"status":`)
							fflib.WriteJsonString(buf, string(v.Detail.Status))
							buf.WriteByte('}')
						} else {
							buf.WriteString(`{ "detail":null`)
						}
						buf.WriteByte('}')
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"address":`)
				if v.Resource.Address != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Address {
						if i != 0 {
							buf.WriteString(`,`)
						}

						{

							err = v.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"addresses":`)
				if v.Resource.Addresses != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Addresses {
						if i != 0 {
							buf.WriteString(`,`)
						}

						{

							err = v.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"authoredOn":`)

				{

					obj, err = v.Resource.AuthoredOn.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
				buf.WriteString(`,"billablePeriod":`)

				{

					err = v.Resource.BillablePeriod.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"birthDate":`)
				fflib.WriteJsonString(buf, string(v.Resource.BirthDate))
				buf.WriteString(`,"careTeam":`)
				if v.Resource.CareTeam != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.CareTeam {
						if i != 0 {
							buf.WriteString(`,`)
						}
						/* Inline struct. type=struct { Provider tmp.syntheaReference "json:\"provider\""; Reference string "json:\"reference\""; Role tmp.syntheaCode "json:\"role\""; Sequence int64 "json:\"sequence\"" } kind=struct */
						buf.WriteString(`{ "provider":`)

						{

							err = v.Provider.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"reference":`)
						fflib.WriteJsonString(buf, string(v.Reference))
						buf.WriteString(`,"role":`)

						{

							err = v.Role.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"sequence":`)
						fflib.FormatBits2(buf, uint64(v.Sequence), 10, v.Sequence < 0)
						buf.WriteByte('}')
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"category":`)
				if v.Resource.Category != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Category {
						if i != 0 {
							buf.WriteString(`,`)
						}

						{

							err = v.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"claim":`)

				{

					err = v.Resource.Claim.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"class":`)

				{

					err = v.Resource.Class.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"clinicalStatus":`)

				{

					err = v.Resource.ClinicalStatus.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"code":`)

				{

					err = v.Resource.Code.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"communication":`)
				if v.Resource.Communication != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Communication {
						if i != 0 {
							buf.WriteString(`,`)
						}
						/* Inline struct. type=struct { Language tmp.syntheaCode "json:\"language\"" } kind=struct */
						buf.WriteString(`{ "language":`)

						{

							err = v.Language.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteByte('}')
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"component":`)
				if v.Resource.Component != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Component {
						if i != 0 {
							buf.WriteString(`,`)
						}
						/* Inline struct. type=struct { Code tmp.syntheaCode "json:\"code\""; ValueQuantity tmp.syntheaCoding "json:\"valueQuantity\"" } kind=struct */
						buf.WriteString(`{ "code":`)

						{

							err = v.Code.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"valueQuantity":`)

						{

							err = v.ValueQuantity.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteByte('}')
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"contained":`)
				if v.Resource.Contained != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Contained {
						if i != 0 {
							buf.WriteString(`,`)
						}
						/* Inline struct. type=struct { Beneficiary tmp.syntheaReference "json:\"beneficiary\""; ID string "json:\"id\""; Intent string "json:\"intent\""; Payor []tmp.syntheaReference "json:\"payor\""; Performer []tmp.syntheaReference "json:\"performer\""; Requester tmp.syntheaReference "json:\"requester\""; ResourceType string "json:\"resourceType\""; Status string "json:\"status\""; Subject tmp.syntheaReference "json:\"subject\""; Type tmp.syntheaCode "json:\"type\"" } kind=struct */
						buf.WriteString(`{ "beneficiary":`)

						{

							err = v.Beneficiary.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"id":`)
						fflib.WriteJsonString(buf, string(v.ID))
						buf.WriteString(`,"intent":`)
						fflib.WriteJsonString(buf, string(v.Intent))
						buf.WriteString(`,"payor":`)
						if v.Payor != nil {
							buf.WriteString(`[`)
							for i, v := range v.Payor {
								if i != 0 {
									buf.WriteString(`,`)
								}

								{

									err = v.MarshalJSONBuf(buf)
									if err != nil {
										return err
									}

								}
							}
							buf.WriteString(`]`)
						} else {
							buf.WriteString(`null`)
						}
						buf.WriteString(`,"performer":`)
						if v.Performer != nil {
							buf.WriteString(`[`)
							for i, v := range v.Performer {
								if i != 0 {
									buf.WriteString(`,`)
								}

								{

									err = v.MarshalJSONBuf(buf)
									if err != nil {
										return err
									}

								}
							}
							buf.WriteString(`]`)
						} else {
							buf.WriteString(`null`)
						}
						buf.WriteString(`,"requester":`)

						{

							err = v.Requester.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"resourceType":`)
						fflib.WriteJsonString(buf, string(v.ResourceType))
						buf.WriteString(`,"status":`)
						fflib.WriteJsonString(buf, string(v.Status))
						buf.WriteString(`,"subject":`)

						{

							err = v.Subject.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"type":`)

						{

							err = v.Type.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteByte('}')
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"created":`)

				{

					obj, err = v.Resource.Created.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
				buf.WriteString(`,"deceasedDateTime":`)

				{

					obj, err = v.Resource.DeceasedDateTime.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
				buf.WriteString(`,"description":`)

				{

					err = v.Resource.Description.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"diagnosis":`)
				if v.Resource.Diagnosis != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Diagnosis {
						if i != 0 {
							buf.WriteString(`,`)
						}
						/* Inline struct. type=struct { DiagnosisReference tmp.syntheaReference "json:\"diagnosisReference\""; Sequence int64 "json:\"sequence\""; Type []tmp.syntheaCode "json:\"type\"" } kind=struct */
						buf.WriteString(`{ "diagnosisReference":`)

						{

							err = v.DiagnosisReference.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"sequence":`)
						fflib.FormatBits2(buf, uint64(v.Sequence), 10, v.Sequence < 0)
						buf.WriteString(`,"type":`)
						if v.Type != nil {
							buf.WriteString(`[`)
							for i, v := range v.Type {
								if i != 0 {
									buf.WriteString(`,`)
								}

								{

									err = v.MarshalJSONBuf(buf)
									if err != nil {
										return err
									}

								}
							}
							buf.WriteString(`]`)
						} else {
							buf.WriteString(`null`)
						}
						buf.WriteByte('}')
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"dosageInstruction":`)
				if v.Resource.DosageInstruction != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.DosageInstruction {
						if i != 0 {
							buf.WriteString(`,`)
						}
						/* Inline struct. type=struct { AsNeededBoolean bool "json:\"asNeededBoolean\""; DoseAndRate []struct { DoseQuantity *struct { Value float64 "json:\"value\"" } "json:\"doseQuantity\""; Type tmp.syntheaCode "json:\"type\"" } "json:\"doseAndRate\""; Sequence int64 "json:\"sequence\""; Timing *struct { Repeat *struct { Frequency int64 "json:\"frequency\""; Period float64 "json:\"period\""; PeriodUnit string "json:\"periodUnit\"" } "json:\"repeat\"" } "json:\"timing\"" } kind=struct */
						if v.AsNeededBoolean {
							buf.WriteString(`{ "asNeededBoolean":true`)
						} else {
							buf.WriteString(`{ "asNeededBoolean":false`)
						}
						buf.WriteString(`,"doseAndRate":`)
						if v.DoseAndRate != nil {
							buf.WriteString(`[`)
							for i, v := range v.DoseAndRate {
								if i != 0 {
									buf.WriteString(`,`)
								}
								/* Inline struct. type=struct { DoseQuantity *struct { Value float64 "json:\"value\"" } "json:\"doseQuantity\""; Type tmp.syntheaCode "json:\"type\"" } kind=struct */
								if v.DoseQuantity != nil {
									/* Inline struct. type=struct { Value float64 "json:\"value\"" } kind=struct */
									buf.WriteString(`{ "doseQuantity":{ "value":`)
									fflib.AppendFloat(buf, float64(v.DoseQuantity.Value), 'g', -1, 64)
									buf.WriteByte('}')
								} else {
									buf.WriteString(`{ "doseQuantity":null`)
								}
								buf.WriteString(`,"type":`)

								{

									err = v.Type.MarshalJSONBuf(buf)
									if err != nil {
										return err
									}

								}
								buf.WriteByte('}')
							}
							buf.WriteString(`]`)
						} else {
							buf.WriteString(`null`)
						}
						buf.WriteString(`,"sequence":`)
						fflib.FormatBits2(buf, uint64(v.Sequence), 10, v.Sequence < 0)
						if v.Timing != nil {
							/* Inline struct. type=struct { Repeat *struct { Frequency int64 "json:\"frequency\""; Period float64 "json:\"period\""; PeriodUnit string "json:\"periodUnit\"" } "json:\"repeat\"" } kind=struct */
							if v.Timing.Repeat != nil {
								/* Inline struct. type=struct { Frequency int64 "json:\"frequency\""; Period float64 "json:\"period\""; PeriodUnit string "json:\"periodUnit\"" } kind=struct */
								buf.WriteString(`,"timing":{ "repeat":{ "frequency":`)
								fflib.FormatBits2(buf, uint64(v.Timing.Repeat.Frequency), 10, v.Timing.Repeat.Frequency < 0)
								buf.WriteString(`,"period":`)
								fflib.AppendFloat(buf, float64(v.Timing.Repeat.Period), 'g', -1, 64)
								buf.WriteString(`,"periodUnit":`)
								fflib.WriteJsonString(buf, string(v.Timing.Repeat.PeriodUnit))
								buf.WriteByte('}')
							} else {
								buf.WriteString(`,"timing":{ "repeat":null`)
							}
							buf.WriteByte('}')
						} else {
							buf.WriteString(`,"timing":null`)
						}
						buf.WriteByte('}')
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"effectiveDateTime":`)

				{

					obj, err = v.Resource.EffectiveDateTime.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
				buf.WriteString(`,"encounter":`)

				{

					err = v.Resource.Encounter.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"extension":`)
				if v.Resource.Extension != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Extension {
						if i != 0 {
							buf.WriteString(`,`)
						}

						{

							err = v.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"gender":`)
				fflib.WriteJsonString(buf, string(v.Resource.Gender))
				buf.WriteString(`,"goal":`)
				if v.Resource.Goal != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Goal {
						if i != 0 {
							buf.WriteString(`,`)
						}

						{

							err = v.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"id":`)
				fflib.WriteJsonString(buf, string(v.Resource.ID))
				buf.WriteString(`,"identifier":`)
				if v.Resource.Identifier != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Identifier {
						if i != 0 {
							buf.WriteString(`,`)
						}
						/* Inline struct. type=struct { System string "json:\"system\""; Type tmp.syntheaCode "json:\"type\""; Use string "json:\"use\""; Value string "json:\"value\"" } kind=struct */
						buf.WriteString(`{ "system":`)
						fflib.WriteJsonString(buf, string(v.System))
						buf.WriteString(`,"type":`)

						{

							err = v.Type.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"use":`)
						fflib.WriteJsonString(buf, string(v.Use))
						buf.WriteString(`,"value":`)
						fflib.WriteJsonString(buf, string(v.Value))
						buf.WriteByte('}')
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"insurance":`)
				if v.Resource.Insurance != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Insurance {
						if i != 0 {
							buf.WriteString(`,`)
						}
						/* Inline struct. type=struct { Coverage tmp.syntheaReference "json:\"coverage\""; Focal bool "json:\"focal\""; Sequence int64 "json:\"sequence\"" } kind=struct */
						buf.WriteString(`{ "coverage":`)

						{

							err = v.Coverage.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						if v.Focal {
							buf.WriteString(`,"focal":true`)
						} else {
							buf.WriteString(`,"focal":false`)
						}
						buf.WriteString(`,"sequence":`)
						fflib.FormatBits2(buf, uint64(v.Sequence), 10, v.Sequence < 0)
						buf.WriteByte('}')
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"insurer":`)

				{

					err = v.Resource.Insurer.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"intent":`)
				fflib.WriteJsonString(buf, string(v.Resource.Intent))
				buf.WriteString(`,"issued":`)

				{

					obj, err = v.Resource.Issued.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
				buf.WriteString(`,"item":`)
				if v.Resource.Item != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Item {
						if i != 0 {
							buf.WriteString(`,`)
						}
						/* Inline struct. type=struct { Adjudication []struct { Amount tmp.syntheaCurrency "json:\"amount\""; Category tmp.syntheaCode "json:\"category\"" } "json:\"adjudication\""; Category tmp.syntheaCode "json:\"category\""; DiagnosisSequence []int64 "json:\"diagnosisSequence\""; Encounter []tmp.syntheaReference "json:\"encounter\""; InformationSequence []int64 "json:\"informationSequence\""; LocationCodeableConcept tmp.syntheaCode "json:\"locationCodeableConcept\""; Net tmp.syntheaCurrency "json:\"net\""; ProcedureSequence []int64 "json:\"procedureSequence\""; ProductOrService tmp.syntheaCode "json:\"productOrService\""; Sequence int64 "json:\"sequence\""; ServicedPeriod tmp.syntheaRange "json:\"servicedPeriod\"" } kind=struct */
						buf.WriteString(`{ "adjudication":`)
						if v.Adjudication != nil {
							buf.WriteString(`[`)
							for i, v := range v.Adjudication {
								if i != 0 {
									buf.WriteString(`,`)
								}
								/* Inline struct. type=struct { Amount tmp.syntheaCurrency "json:\"amount\""; Category tmp.syntheaCode "json:\"category\"" } kind=struct */
								buf.WriteString(`{ "amount":`)

								{

									err = v.Amount.MarshalJSONBuf(buf)
									if err != nil {
										return err
									}

								}
								buf.WriteString(`,"category":`)

								{

									err = v.Category.MarshalJSONBuf(buf)
									if err != nil {
										return err
									}

								}
								buf.WriteByte('}')
							}
							buf.WriteString(`]`)
						} else {
							buf.WriteString(`null`)
						}
						buf.WriteString(`,"category":`)

						{

							err = v.Category.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"diagnosisSequence":`)
						if v.DiagnosisSequence != nil {
							buf.WriteString(`[`)
							for i, v := range v.DiagnosisSequence {
								if i != 0 {
									buf.WriteString(`,`)
								}
								fflib.FormatBits2(buf, uint64(v), 10, v < 0)
							}
							buf.WriteString(`]`)
						} else {
							buf.WriteString(`null`)
						}
						buf.WriteString(`,"encounter":`)
						if v.Encounter != nil {
							buf.WriteString(`[`)
							for i, v := range v.Encounter {
								if i != 0 {
									buf.WriteString(`,`)
								}

								{

									err = v.MarshalJSONBuf(buf)
									if err != nil {
										return err
									}

								}
							}
							buf.WriteString(`]`)
						} else {
							buf.WriteString(`null`)
						}
						buf.WriteString(`,"informationSequence":`)
						if v.InformationSequence != nil {
							buf.WriteString(`[`)
							for i, v := range v.InformationSequence {
								if i != 0 {
									buf.WriteString(`,`)
								}
								fflib.FormatBits2(buf, uint64(v), 10, v < 0)
							}
							buf.WriteString(`]`)
						} else {
							buf.WriteString(`null`)
						}
						buf.WriteString(`,"locationCodeableConcept":`)

						{

							err = v.LocationCodeableConcept.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"net":`)

						{

							err = v.Net.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"procedureSequence":`)
						if v.ProcedureSequence != nil {
							buf.WriteString(`[`)
							for i, v := range v.ProcedureSequence {
								if i != 0 {
									buf.WriteString(`,`)
								}
								fflib.FormatBits2(buf, uint64(v), 10, v < 0)
							}
							buf.WriteString(`]`)
						} else {
							buf.WriteString(`null`)
						}
						buf.WriteString(`,"productOrService":`)

						{

							err = v.ProductOrService.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"sequence":`)
						fflib.FormatBits2(buf, uint64(v.Sequence), 10, v.Sequence < 0)
						buf.WriteString(`,"servicedPeriod":`)

						{

							err = v.ServicedPeriod.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteByte('}')
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"lifecycleStatus":`)
				fflib.WriteJsonString(buf, string(v.Resource.LifecycleStatus))
				buf.WriteString(`,"managingOrganization":`)
				if v.Resource.ManagingOrganization != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.ManagingOrganization {
						if i != 0 {
							buf.WriteString(`,`)
						}

						{

							err = v.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"maritalStatus":`)

				{

					err = v.Resource.MaritalStatus.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"medicationCodeableConcept":`)

				{

					err = v.Resource.MedicationCodeableConcept.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				if v.Resource.MultipleBirthBoolean {
					buf.WriteString(`,"multipleBirthBoolean":true`)
				} else {
					buf.WriteString(`,"multipleBirthBoolean":false`)
				}
				buf.WriteString(`,"name":`)

				{

					obj, err = v.Resource.Name.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
				buf.WriteString(`,"numberOfInstances":`)
				fflib.FormatBits2(buf, uint64(v.Resource.NumberOfInstances), 10, v.Resource.NumberOfInstances < 0)
				buf.WriteString(`,"numberOfSeries":`)
				fflib.FormatBits2(buf, uint64(v.Resource.NumberOfSeries), 10, v.Resource.NumberOfSeries < 0)
				buf.WriteString(`,"occurrenceDateTime":`)

				{

					obj, err = v.Resource.OccurrenceDateTime.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
				buf.WriteString(`,"onsetDateTime":`)

				{

					obj, err = v.Resource.OnsetDateTime.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
				buf.WriteString(`,"outcome":`)
				fflib.WriteJsonString(buf, string(v.Resource.Outcome))
				buf.WriteString(`,"participant":`)
				if v.Resource.Participant != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Participant {
						if i != 0 {
							buf.WriteString(`,`)
						}
						/* Inline struct. type=struct { Individual tmp.syntheaReference "json:\"individual\""; Member tmp.syntheaReference "json:\"member\""; Role []tmp.syntheaCode "json:\"role\"" } kind=struct */
						buf.WriteString(`{ "individual":`)

						{

							err = v.Individual.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"member":`)

						{

							err = v.Member.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"role":`)
						if v.Role != nil {
							buf.WriteString(`[`)
							for i, v := range v.Role {
								if i != 0 {
									buf.WriteString(`,`)
								}

								{

									err = v.MarshalJSONBuf(buf)
									if err != nil {
										return err
									}

								}
							}
							buf.WriteString(`]`)
						} else {
							buf.WriteString(`null`)
						}
						buf.WriteByte('}')
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"patient":`)

				{

					err = v.Resource.Patient.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				if v.Resource.Payment != nil {
					/* Inline struct. type=struct { Amount tmp.syntheaCurrency "json:\"amount\"" } kind=struct */
					buf.WriteString(`,"payment":{ "amount":`)

					{

						err = v.Resource.Payment.Amount.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}
					buf.WriteByte('}')
				} else {
					buf.WriteString(`,"payment":null`)
				}
				buf.WriteString(`,"performedPeriod":`)

				{

					err = v.Resource.PerformedPeriod.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"period":`)

				{

					err = v.Resource.Period.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"prescription":`)

				{

					err = v.Resource.Prescription.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				if v.Resource.PrimarySource {
					buf.WriteString(`,"primarySource":true`)
				} else {
					buf.WriteString(`,"primarySource":false`)
				}
				buf.WriteString(`,"priority":`)

				{

					err = v.Resource.Priority.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"procedure":`)
				if v.Resource.Procedure != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Procedure {
						if i != 0 {
							buf.WriteString(`,`)
						}
						/* Inline struct. type=struct { ProcedureReference tmp.syntheaReference "json:\"procedureReference\""; Sequence int64 "json:\"sequence\"" } kind=struct */
						buf.WriteString(`{ "procedureReference":`)

						{

							err = v.ProcedureReference.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"sequence":`)
						fflib.FormatBits2(buf, uint64(v.Sequence), 10, v.Sequence < 0)
						buf.WriteByte('}')
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"provider":`)

				{

					err = v.Resource.Provider.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"reasonCode":`)
				if v.Resource.ReasonCode != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.ReasonCode {
						if i != 0 {
							buf.WriteString(`,`)
						}

						{

							err = v.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"reasonReference":`)
				if v.Resource.ReasonReference != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.ReasonReference {
						if i != 0 {
							buf.WriteString(`,`)
						}

						{

							err = v.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"recordedDate":`)

				{

					obj, err = v.Resource.RecordedDate.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
				buf.WriteString(`,"referral":`)

				{

					err = v.Resource.Referral.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"requester":`)

				{

					err = v.Resource.Requester.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"resourceType":`)
				fflib.WriteJsonString(buf, string(v.Resource.ResourceType))
				buf.WriteString(`,"result":`)
				if v.Resource.Result != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Result {
						if i != 0 {
							buf.WriteString(`,`)
						}

						{

							err = v.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"series":`)
				if v.Resource.Series != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Series {
						if i != 0 {
							buf.WriteString(`,`)
						}
						/* Inline struct. type=struct { BodySite tmp.syntheaCoding "json:\"bodySite\""; Instance []struct { Number int64 "json:\"number\""; SopClass tmp.syntheaCoding "json:\"sopClass\""; Title string "json:\"title\""; UID string "json:\"uid\"" } "json:\"instance\""; Modality tmp.syntheaCoding "json:\"modality\""; Number int64 "json:\"number\""; NumberOfInstances int64 "json:\"numberOfInstances\""; Started string "json:\"started\""; UID string "json:\"uid\"" } kind=struct */
						buf.WriteString(`{ "bodySite":`)

						{

							err = v.BodySite.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"instance":`)
						if v.Instance != nil {
							buf.WriteString(`[`)
							for i, v := range v.Instance {
								if i != 0 {
									buf.WriteString(`,`)
								}
								/* Inline struct. type=struct { Number int64 "json:\"number\""; SopClass tmp.syntheaCoding "json:\"sopClass\""; Title string "json:\"title\""; UID string "json:\"uid\"" } kind=struct */
								buf.WriteString(`{ "number":`)
								fflib.FormatBits2(buf, uint64(v.Number), 10, v.Number < 0)
								buf.WriteString(`,"sopClass":`)

								{

									err = v.SopClass.MarshalJSONBuf(buf)
									if err != nil {
										return err
									}

								}
								buf.WriteString(`,"title":`)
								fflib.WriteJsonString(buf, string(v.Title))
								buf.WriteString(`,"uid":`)
								fflib.WriteJsonString(buf, string(v.UID))
								buf.WriteByte('}')
							}
							buf.WriteString(`]`)
						} else {
							buf.WriteString(`null`)
						}
						buf.WriteString(`,"modality":`)

						{

							err = v.Modality.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"number":`)
						fflib.FormatBits2(buf, uint64(v.Number), 10, v.Number < 0)
						buf.WriteString(`,"numberOfInstances":`)
						fflib.FormatBits2(buf, uint64(v.NumberOfInstances), 10, v.NumberOfInstances < 0)
						buf.WriteString(`,"started":`)
						fflib.WriteJsonString(buf, string(v.Started))
						buf.WriteString(`,"uid":`)
						fflib.WriteJsonString(buf, string(v.UID))
						buf.WriteByte('}')
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"serviceProvider":`)

				{

					err = v.Resource.ServiceProvider.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"started":`)

				{

					obj, err = v.Resource.Started.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
				buf.WriteString(`,"status":`)
				fflib.WriteJsonString(buf, string(v.Resource.Status))
				buf.WriteString(`,"subject":`)

				{

					err = v.Resource.Subject.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"supportingInfo":`)
				if v.Resource.SupportingInfo != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.SupportingInfo {
						if i != 0 {
							buf.WriteString(`,`)
						}
						/* Inline struct. type=struct { Category tmp.syntheaCode "json:\"category\""; Sequence int64 "json:\"sequence\""; ValueReference tmp.syntheaReference "json:\"valueReference\"" } kind=struct */
						buf.WriteString(`{ "category":`)

						{

							err = v.Category.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteString(`,"sequence":`)
						fflib.FormatBits2(buf, uint64(v.Sequence), 10, v.Sequence < 0)
						buf.WriteString(`,"valueReference":`)

						{

							err = v.ValueReference.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}
						buf.WriteByte('}')
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				buf.WriteString(`,"telecom":`)
				if v.Resource.Telecom != nil {
					buf.WriteString(`[`)
					for i, v := range v.Resource.Telecom {
						if i != 0 {
							buf.WriteString(`,`)
						}
						if v == nil {
							buf.WriteString(`null`)
						} else {
							buf.WriteString(`{ `)
							for key, value := range v {
								fflib.WriteJsonString(buf, key)
								buf.WriteString(`:`)
								fflib.WriteJsonString(buf, string(value))
								buf.WriteByte(',')
							}
							buf.Rewind(1)
							buf.WriteByte('}')
						}
					}
					buf.WriteString(`]`)
				} else {
					buf.WriteString(`null`)
				}
				if v.Resource.Text == nil {
					buf.WriteString(`,"text":null`)
				} else {
					buf.WriteString(`,"text":{ `)
					for key, value := range v.Resource.Text {
						fflib.WriteJsonString(buf, key)
						buf.WriteString(`:`)
						fflib.WriteJsonString(buf, string(value))
						buf.WriteByte(',')
					}
					buf.Rewind(1)
					buf.WriteByte('}')
				}
				buf.WriteString(`,"total":`)

				{

					obj, err = v.Resource.Total.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
				buf.WriteString(`,"type":`)

				{

					obj, err = v.Resource.Type.MarshalJSON()
					if err != nil {
						return err
					}
					buf.Write(obj)

				}
				buf.WriteString(`,"use":`)
				fflib.WriteJsonString(buf, string(v.Resource.Use))
				buf.WriteString(`,"vaccineCode":`)

				{

					err = v.Resource.VaccineCode.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"valueCodeableConcept":`)

				{

					err = v.Resource.ValueCodeableConcept.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"valueQuantity":`)

				{

					err = v.Resource.ValueQuantity.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteString(`,"verificationStatus":`)

				{

					err = v.Resource.VerificationStatus.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
				buf.WriteByte('}')
			} else {
				buf.WriteString(`,"resource":null`)
			}
			buf.WriteByte('}')
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"resourceType":`)
	fflib.WriteJsonString(buf, string(j.ResourceType))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtsyntheaRootbase = iota
	ffjtsyntheaRootnosuchkey

	ffjtsyntheaRootEntry

	ffjtsyntheaRootResourceType

	ffjtsyntheaRootType
)

var ffjKeysyntheaRootEntry = []byte("entry")

var ffjKeysyntheaRootResourceType = []byte("resourceType")

var ffjKeysyntheaRootType = []byte("type")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *syntheaRoot) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtsyntheaRootbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtsyntheaRootnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffjKeysyntheaRootEntry, kn) {
						currentKey = ffjtsyntheaRootEntry
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeysyntheaRootResourceType, kn) {
						currentKey = ffjtsyntheaRootResourceType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeysyntheaRootType, kn) {
						currentKey = ffjtsyntheaRootType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaRootType, kn) {
					currentKey = ffjtsyntheaRootType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeysyntheaRootResourceType, kn) {
					currentKey = ffjtsyntheaRootResourceType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeysyntheaRootEntry, kn) {
					currentKey = ffjtsyntheaRootEntry
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtsyntheaRootnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtsyntheaRootEntry:
					goto handle_Entry

				case ffjtsyntheaRootResourceType:
					goto handle_ResourceType

				case ffjtsyntheaRootType:
					goto handle_Type

				case ffjtsyntheaRootnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Entry:

	/* handler: j.Entry type=[]struct { FullURL string "json:\"fullUrl\""; Request *struct { Method string "json:\"method\""; URL string "json:\"url\"" } "json:\"request\""; Resource *struct { AbatementDateTime time.Time "json:\"abatementDateTime\""; AchievementStatus tmp.syntheaCode "json:\"achievementStatus\""; Active bool "json:\"active\""; Activity []struct { Detail *struct { Code tmp.syntheaCode "json:\"code\""; Location tmp.syntheaReference "json:\"location\""; Status string "json:\"status\"" } "json:\"detail\"" } "json:\"activity\""; Address []tmp.syntheaAddress "json:\"address\""; Addresses []tmp.syntheaReference "json:\"addresses\""; AuthoredOn time.Time "json:\"authoredOn\""; BillablePeriod tmp.syntheaRange "json:\"billablePeriod\""; BirthDate string "json:\"birthDate\""; CareTeam []struct { Provider tmp.syntheaReference "json:\"provider\""; Reference string "json:\"reference\""; Role tmp.syntheaCode "json:\"role\""; Sequence int64 "json:\"sequence\"" } "json:\"careTeam\""; Category []tmp.syntheaCode "json:\"category\""; Claim tmp.syntheaReference "json:\"claim\""; Class tmp.syntheaCoding "json:\"class\""; ClinicalStatus tmp.syntheaCode "json:\"clinicalStatus\""; Code tmp.syntheaCode "json:\"code\""; Communication []struct { Language tmp.syntheaCode "json:\"language\"" } "json:\"communication\""; Component []struct { Code tmp.syntheaCode "json:\"code\""; ValueQuantity tmp.syntheaCoding "json:\"valueQuantity\"" } "json:\"component\""; Contained []struct { Beneficiary tmp.syntheaReference "json:\"beneficiary\""; ID string "json:\"id\""; Intent string "json:\"intent\""; Payor []tmp.syntheaReference "json:\"payor\""; Performer []tmp.syntheaReference "json:\"performer\""; Requester tmp.syntheaReference "json:\"requester\""; ResourceType string "json:\"resourceType\""; Status string "json:\"status\""; Subject tmp.syntheaReference "json:\"subject\""; Type tmp.syntheaCode "json:\"type\"" } "json:\"contained\""; Created time.Time "json:\"created\""; DeceasedDateTime time.Time "json:\"deceasedDateTime\""; Description tmp.syntheaCode "json:\"description\""; Diagnosis []struct { DiagnosisReference tmp.syntheaReference "json:\"diagnosisReference\""; Sequence int64 "json:\"sequence\""; Type []tmp.syntheaCode "json:\"type\"" } "json:\"diagnosis\""; DosageInstruction []struct { AsNeededBoolean bool "json:\"asNeededBoolean\""; DoseAndRate []struct { DoseQuantity *struct { Value float64 "json:\"value\"" } "json:\"doseQuantity\""; Type tmp.syntheaCode "json:\"type\"" } "json:\"doseAndRate\""; Sequence int64 "json:\"sequence\""; Timing *struct { Repeat *struct { Frequency int64 "json:\"frequency\""; Period float64 "json:\"period\""; PeriodUnit string "json:\"periodUnit\"" } "json:\"repeat\"" } "json:\"timing\"" } "json:\"dosageInstruction\""; EffectiveDateTime time.Time "json:\"effectiveDateTime\""; Encounter tmp.syntheaReference "json:\"encounter\""; Extension []tmp.syntheaExtension "json:\"extension\""; Gender string "json:\"gender\""; Goal []tmp.syntheaReference "json:\"goal\""; ID string "json:\"id\""; Identifier []struct { System string "json:\"system\""; Type tmp.syntheaCode "json:\"type\""; Use string "json:\"use\""; Value string "json:\"value\"" } "json:\"identifier\""; Insurance []struct { Coverage tmp.syntheaReference "json:\"coverage\""; Focal bool "json:\"focal\""; Sequence int64 "json:\"sequence\"" } "json:\"insurance\""; Insurer tmp.syntheaReference "json:\"insurer\""; Intent string "json:\"intent\""; Issued time.Time "json:\"issued\""; Item []struct { Adjudication []struct { Amount tmp.syntheaCurrency "json:\"amount\""; Category tmp.syntheaCode "json:\"category\"" } "json:\"adjudication\""; Category tmp.syntheaCode "json:\"category\""; DiagnosisSequence []int64 "json:\"diagnosisSequence\""; Encounter []tmp.syntheaReference "json:\"encounter\""; InformationSequence []int64 "json:\"informationSequence\""; LocationCodeableConcept tmp.syntheaCode "json:\"locationCodeableConcept\""; Net tmp.syntheaCurrency "json:\"net\""; ProcedureSequence []int64 "json:\"procedureSequence\""; ProductOrService tmp.syntheaCode "json:\"productOrService\""; Sequence int64 "json:\"sequence\""; ServicedPeriod tmp.syntheaRange "json:\"servicedPeriod\"" } "json:\"item\""; LifecycleStatus string "json:\"lifecycleStatus\""; ManagingOrganization []tmp.syntheaReference "json:\"managingOrganization\""; MaritalStatus tmp.syntheaCode "json:\"maritalStatus\""; MedicationCodeableConcept tmp.syntheaCode "json:\"medicationCodeableConcept\""; MultipleBirthBoolean bool "json:\"multipleBirthBoolean\""; Name jsontext.Value "json:\"name\""; NumberOfInstances int64 "json:\"numberOfInstances\""; NumberOfSeries int64 "json:\"numberOfSeries\""; OccurrenceDateTime time.Time "json:\"occurrenceDateTime\""; OnsetDateTime time.Time "json:\"onsetDateTime\""; Outcome string "json:\"outcome\""; Participant []struct { Individual tmp.syntheaReference "json:\"individual\""; Member tmp.syntheaReference "json:\"member\""; Role []tmp.syntheaCode "json:\"role\"" } "json:\"participant\""; Patient tmp.syntheaReference "json:\"patient\""; Payment *struct { Amount tmp.syntheaCurrency "json:\"amount\"" } "json:\"payment\""; PerformedPeriod tmp.syntheaRange "json:\"performedPeriod\""; Period tmp.syntheaRange "json:\"period\""; Prescription tmp.syntheaReference "json:\"prescription\""; PrimarySource bool "json:\"primarySource\""; Priority tmp.syntheaCode "json:\"priority\""; Procedure []struct { ProcedureReference tmp.syntheaReference "json:\"procedureReference\""; Sequence int64 "json:\"sequence\"" } "json:\"procedure\""; Provider tmp.syntheaReference "json:\"provider\""; ReasonCode []tmp.syntheaCode "json:\"reasonCode\""; ReasonReference []tmp.syntheaReference "json:\"reasonReference\""; RecordedDate time.Time "json:\"recordedDate\""; Referral tmp.syntheaReference "json:\"referral\""; Requester tmp.syntheaReference "json:\"requester\""; ResourceType string "json:\"resourceType\""; Result []tmp.syntheaReference "json:\"result\""; Series []struct { BodySite tmp.syntheaCoding "json:\"bodySite\""; Instance []struct { Number int64 "json:\"number\""; SopClass tmp.syntheaCoding "json:\"sopClass\""; Title string "json:\"title\""; UID string "json:\"uid\"" } "json:\"instance\""; Modality tmp.syntheaCoding "json:\"modality\""; Number int64 "json:\"number\""; NumberOfInstances int64 "json:\"numberOfInstances\""; Started string "json:\"started\""; UID string "json:\"uid\"" } "json:\"series\""; ServiceProvider tmp.syntheaReference "json:\"serviceProvider\""; Started time.Time "json:\"started\""; Status string "json:\"status\""; Subject tmp.syntheaReference "json:\"subject\""; SupportingInfo []struct { Category tmp.syntheaCode "json:\"category\""; Sequence int64 "json:\"sequence\""; ValueReference tmp.syntheaReference "json:\"valueReference\"" } "json:\"supportingInfo\""; Telecom []map[string]string "json:\"telecom\""; Text map[string]string "json:\"text\""; Total jsontext.Value "json:\"total\""; Type jsontext.Value "json:\"type\""; Use string "json:\"use\""; VaccineCode tmp.syntheaCode "json:\"vaccineCode\""; ValueCodeableConcept tmp.syntheaCode "json:\"valueCodeableConcept\""; ValueQuantity tmp.syntheaCoding "json:\"valueQuantity\""; VerificationStatus tmp.syntheaCode "json:\"verificationStatus\"" } "json:\"resource\"" } kind=slice quoted=false*/

	{
		/* Falling back. type=[]struct { FullURL string "json:\"fullUrl\""; Request *struct { Method string "json:\"method\""; URL string "json:\"url\"" } "json:\"request\""; Resource *struct { AbatementDateTime time.Time "json:\"abatementDateTime\""; AchievementStatus tmp.syntheaCode "json:\"achievementStatus\""; Active bool "json:\"active\""; Activity []struct { Detail *struct { Code tmp.syntheaCode "json:\"code\""; Location tmp.syntheaReference "json:\"location\""; Status string "json:\"status\"" } "json:\"detail\"" } "json:\"activity\""; Address []tmp.syntheaAddress "json:\"address\""; Addresses []tmp.syntheaReference "json:\"addresses\""; AuthoredOn time.Time "json:\"authoredOn\""; BillablePeriod tmp.syntheaRange "json:\"billablePeriod\""; BirthDate string "json:\"birthDate\""; CareTeam []struct { Provider tmp.syntheaReference "json:\"provider\""; Reference string "json:\"reference\""; Role tmp.syntheaCode "json:\"role\""; Sequence int64 "json:\"sequence\"" } "json:\"careTeam\""; Category []tmp.syntheaCode "json:\"category\""; Claim tmp.syntheaReference "json:\"claim\""; Class tmp.syntheaCoding "json:\"class\""; ClinicalStatus tmp.syntheaCode "json:\"clinicalStatus\""; Code tmp.syntheaCode "json:\"code\""; Communication []struct { Language tmp.syntheaCode "json:\"language\"" } "json:\"communication\""; Component []struct { Code tmp.syntheaCode "json:\"code\""; ValueQuantity tmp.syntheaCoding "json:\"valueQuantity\"" } "json:\"component\""; Contained []struct { Beneficiary tmp.syntheaReference "json:\"beneficiary\""; ID string "json:\"id\""; Intent string "json:\"intent\""; Payor []tmp.syntheaReference "json:\"payor\""; Performer []tmp.syntheaReference "json:\"performer\""; Requester tmp.syntheaReference "json:\"requester\""; ResourceType string "json:\"resourceType\""; Status string "json:\"status\""; Subject tmp.syntheaReference "json:\"subject\""; Type tmp.syntheaCode "json:\"type\"" } "json:\"contained\""; Created time.Time "json:\"created\""; DeceasedDateTime time.Time "json:\"deceasedDateTime\""; Description tmp.syntheaCode "json:\"description\""; Diagnosis []struct { DiagnosisReference tmp.syntheaReference "json:\"diagnosisReference\""; Sequence int64 "json:\"sequence\""; Type []tmp.syntheaCode "json:\"type\"" } "json:\"diagnosis\""; DosageInstruction []struct { AsNeededBoolean bool "json:\"asNeededBoolean\""; DoseAndRate []struct { DoseQuantity *struct { Value float64 "json:\"value\"" } "json:\"doseQuantity\""; Type tmp.syntheaCode "json:\"type\"" } "json:\"doseAndRate\""; Sequence int64 "json:\"sequence\""; Timing *struct { Repeat *struct { Frequency int64 "json:\"frequency\""; Period float64 "json:\"period\""; PeriodUnit string "json:\"periodUnit\"" } "json:\"repeat\"" } "json:\"timing\"" } "json:\"dosageInstruction\""; EffectiveDateTime time.Time "json:\"effectiveDateTime\""; Encounter tmp.syntheaReference "json:\"encounter\""; Extension []tmp.syntheaExtension "json:\"extension\""; Gender string "json:\"gender\""; Goal []tmp.syntheaReference "json:\"goal\""; ID string "json:\"id\""; Identifier []struct { System string "json:\"system\""; Type tmp.syntheaCode "json:\"type\""; Use string "json:\"use\""; Value string "json:\"value\"" } "json:\"identifier\""; Insurance []struct { Coverage tmp.syntheaReference "json:\"coverage\""; Focal bool "json:\"focal\""; Sequence int64 "json:\"sequence\"" } "json:\"insurance\""; Insurer tmp.syntheaReference "json:\"insurer\""; Intent string "json:\"intent\""; Issued time.Time "json:\"issued\""; Item []struct { Adjudication []struct { Amount tmp.syntheaCurrency "json:\"amount\""; Category tmp.syntheaCode "json:\"category\"" } "json:\"adjudication\""; Category tmp.syntheaCode "json:\"category\""; DiagnosisSequence []int64 "json:\"diagnosisSequence\""; Encounter []tmp.syntheaReference "json:\"encounter\""; InformationSequence []int64 "json:\"informationSequence\""; LocationCodeableConcept tmp.syntheaCode "json:\"locationCodeableConcept\""; Net tmp.syntheaCurrency "json:\"net\""; ProcedureSequence []int64 "json:\"procedureSequence\""; ProductOrService tmp.syntheaCode "json:\"productOrService\""; Sequence int64 "json:\"sequence\""; ServicedPeriod tmp.syntheaRange "json:\"servicedPeriod\"" } "json:\"item\""; LifecycleStatus string "json:\"lifecycleStatus\""; ManagingOrganization []tmp.syntheaReference "json:\"managingOrganization\""; MaritalStatus tmp.syntheaCode "json:\"maritalStatus\""; MedicationCodeableConcept tmp.syntheaCode "json:\"medicationCodeableConcept\""; MultipleBirthBoolean bool "json:\"multipleBirthBoolean\""; Name jsontext.Value "json:\"name\""; NumberOfInstances int64 "json:\"numberOfInstances\""; NumberOfSeries int64 "json:\"numberOfSeries\""; OccurrenceDateTime time.Time "json:\"occurrenceDateTime\""; OnsetDateTime time.Time "json:\"onsetDateTime\""; Outcome string "json:\"outcome\""; Participant []struct { Individual tmp.syntheaReference "json:\"individual\""; Member tmp.syntheaReference "json:\"member\""; Role []tmp.syntheaCode "json:\"role\"" } "json:\"participant\""; Patient tmp.syntheaReference "json:\"patient\""; Payment *struct { Amount tmp.syntheaCurrency "json:\"amount\"" } "json:\"payment\""; PerformedPeriod tmp.syntheaRange "json:\"performedPeriod\""; Period tmp.syntheaRange "json:\"period\""; Prescription tmp.syntheaReference "json:\"prescription\""; PrimarySource bool "json:\"primarySource\""; Priority tmp.syntheaCode "json:\"priority\""; Procedure []struct { ProcedureReference tmp.syntheaReference "json:\"procedureReference\""; Sequence int64 "json:\"sequence\"" } "json:\"procedure\""; Provider tmp.syntheaReference "json:\"provider\""; ReasonCode []tmp.syntheaCode "json:\"reasonCode\""; ReasonReference []tmp.syntheaReference "json:\"reasonReference\""; RecordedDate time.Time "json:\"recordedDate\""; Referral tmp.syntheaReference "json:\"referral\""; Requester tmp.syntheaReference "json:\"requester\""; ResourceType string "json:\"resourceType\""; Result []tmp.syntheaReference "json:\"result\""; Series []struct { BodySite tmp.syntheaCoding "json:\"bodySite\""; Instance []struct { Number int64 "json:\"number\""; SopClass tmp.syntheaCoding "json:\"sopClass\""; Title string "json:\"title\""; UID string "json:\"uid\"" } "json:\"instance\""; Modality tmp.syntheaCoding "json:\"modality\""; Number int64 "json:\"number\""; NumberOfInstances int64 "json:\"numberOfInstances\""; Started string "json:\"started\""; UID string "json:\"uid\"" } "json:\"series\""; ServiceProvider tmp.syntheaReference "json:\"serviceProvider\""; Started time.Time "json:\"started\""; Status string "json:\"status\""; Subject tmp.syntheaReference "json:\"subject\""; SupportingInfo []struct { Category tmp.syntheaCode "json:\"category\""; Sequence int64 "json:\"sequence\""; ValueReference tmp.syntheaReference "json:\"valueReference\"" } "json:\"supportingInfo\""; Telecom []map[string]string "json:\"telecom\""; Text map[string]string "json:\"text\""; Total jsontext.Value "json:\"total\""; Type jsontext.Value "json:\"type\""; Use string "json:\"use\""; VaccineCode tmp.syntheaCode "json:\"vaccineCode\""; ValueCodeableConcept tmp.syntheaCode "json:\"valueCodeableConcept\""; ValueQuantity tmp.syntheaCoding "json:\"valueQuantity\""; VerificationStatus tmp.syntheaCode "json:\"verificationStatus\"" } "json:\"resource\"" } kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Entry)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ResourceType:

	/* handler: j.ResourceType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ResourceType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *twitterEntities) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"hashtags":`)
	if j.Hashtags != nil {
		buf.WriteString(`[`)
		for i, v := range j.Hashtags {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Interface types must use runtime reflection. type=interface {} kind=interface */
			err = buf.Encode(v)
			if err != nil {
				return err
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"symbols":`)
	if j.Symbols != nil {
		buf.WriteString(`[`)
		for i, v := range j.Symbols {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Interface types must use runtime reflection. type=interface {} kind=interface */
			err = buf.Encode(v)
			if err != nil {
				return err
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	if j.URL != nil {
		buf.WriteString(`,"url":`)

		{

			err = j.URL.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"url":null`)
	}
	buf.WriteString(`,"urls":`)
	if j.URLs != nil {
		buf.WriteString(`[`)
		for i, v := range j.URLs {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"user_mentions":`)
	if j.UserMentions != nil {
		buf.WriteString(`[`)
		for i, v := range j.UserMentions {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Inline struct. type=struct { ScreenName string "json:\"screen_name\""; Name string "json:\"name\""; ID int64 "json:\"id\""; IDStr int64 "json:\"id_str,string\""; Indices []int "json:\"indices\"" } kind=struct */
			buf.WriteString(`{ "screen_name":`)
			fflib.WriteJsonString(buf, string(v.ScreenName))
			buf.WriteString(`,"name":`)
			fflib.WriteJsonString(buf, string(v.Name))
			buf.WriteString(`,"id":`)
			fflib.FormatBits2(buf, uint64(v.ID), 10, v.ID < 0)
			buf.WriteString(`,"id_str":"`)
			fflib.FormatBits2(buf, uint64(v.IDStr), 10, v.IDStr < 0)
			buf.WriteString(`","indices":`)
			if v.Indices != nil {
				buf.WriteString(`[`)
				for i, v := range v.Indices {
					if i != 0 {
						buf.WriteString(`,`)
					}
					fflib.FormatBits2(buf, uint64(v), 10, v < 0)
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
			buf.WriteByte('}')
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	/* Inline struct. type=struct { URLs []tmp.twitterURL "json:\"urls\"" } kind=struct */
	buf.WriteString(`,"description":{ "urls":`)
	if j.Description.URLs != nil {
		buf.WriteString(`[`)
		for i, v := range j.Description.URLs {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	buf.WriteString(`,"media":`)
	if j.Media != nil {
		buf.WriteString(`[`)
		for i, v := range j.Media {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Inline struct. type=struct { ID int64 "json:\"id\""; IDStr string "json:\"id_str\""; Indices []int "json:\"indices\""; MediaURL string "json:\"media_url\""; MediaURLHTTPS string "json:\"media_url_https\""; URL string "json:\"url\""; DisplayURL string "json:\"display_url\""; ExpandedURL string "json:\"expanded_url\""; Type string "json:\"type\""; Sizes map[string]struct { W int "json:\"w\""; H int "json:\"h\""; Resize string "json:\"resize\"" } "json:\"sizes\""; SourceStatusID int64 "json:\"source_status_id\""; SourceStatusIDStr int64 "json:\"source_status_id_str,string\"" } kind=struct */
			buf.WriteString(`{ "id":`)
			fflib.FormatBits2(buf, uint64(v.ID), 10, v.ID < 0)
			buf.WriteString(`,"id_str":`)
			fflib.WriteJsonString(buf, string(v.IDStr))
			buf.WriteString(`,"indices":`)
			if v.Indices != nil {
				buf.WriteString(`[`)
				for i, v := range v.Indices {
					if i != 0 {
						buf.WriteString(`,`)
					}
					fflib.FormatBits2(buf, uint64(v), 10, v < 0)
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
			buf.WriteString(`,"media_url":`)
			fflib.WriteJsonString(buf, string(v.MediaURL))
			buf.WriteString(`,"media_url_https":`)
			fflib.WriteJsonString(buf, string(v.MediaURLHTTPS))
			buf.WriteString(`,"url":`)
			fflib.WriteJsonString(buf, string(v.URL))
			buf.WriteString(`,"display_url":`)
			fflib.WriteJsonString(buf, string(v.DisplayURL))
			buf.WriteString(`,"expanded_url":`)
			fflib.WriteJsonString(buf, string(v.ExpandedURL))
			buf.WriteString(`,"type":`)
			fflib.WriteJsonString(buf, string(v.Type))
			buf.WriteString(`,"sizes":`)
			/* Falling back. type=map[string]struct { W int "json:\"w\""; H int "json:\"h\""; Resize string "json:\"resize\"" } kind=map */
			err = buf.Encode(v.Sizes)
			if err != nil {
				return err
			}
			buf.WriteString(`,"source_status_id":`)
			fflib.FormatBits2(buf, uint64(v.SourceStatusID), 10, v.SourceStatusID < 0)
			buf.WriteString(`,"source_status_id_str":"`)
			fflib.FormatBits2(buf, uint64(v.SourceStatusIDStr), 10, v.SourceStatusIDStr < 0)
			buf.WriteString(`"}`)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjttwitterEntitiesbase = iota
	ffjttwitterEntitiesnosuchkey

	ffjttwitterEntitiesHashtags

	ffjttwitterEntitiesSymbols

	ffjttwitterEntitiesURL

	ffjttwitterEntitiesURLs

	ffjttwitterEntitiesUserMentions

	ffjttwitterEntitiesDescription

	ffjttwitterEntitiesMedia
)

var ffjKeytwitterEntitiesHashtags = []byte("hashtags")

var ffjKeytwitterEntitiesSymbols = []byte("symbols")

var ffjKeytwitterEntitiesURL = []byte("url")

var ffjKeytwitterEntitiesURLs = []byte("urls")

var ffjKeytwitterEntitiesUserMentions = []byte("user_mentions")

var ffjKeytwitterEntitiesDescription = []byte("description")

var ffjKeytwitterEntitiesMedia = []byte("media")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *twitterEntities) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjttwitterEntitiesbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjttwitterEntitiesnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeytwitterEntitiesDescription, kn) {
						currentKey = ffjttwitterEntitiesDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeytwitterEntitiesHashtags, kn) {
						currentKey = ffjttwitterEntitiesHashtags
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeytwitterEntitiesMedia, kn) {
						currentKey = ffjttwitterEntitiesMedia
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeytwitterEntitiesSymbols, kn) {
						currentKey = ffjttwitterEntitiesSymbols
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeytwitterEntitiesURL, kn) {
						currentKey = ffjttwitterEntitiesURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterEntitiesURLs, kn) {
						currentKey = ffjttwitterEntitiesURLs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterEntitiesUserMentions, kn) {
						currentKey = ffjttwitterEntitiesUserMentions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterEntitiesMedia, kn) {
					currentKey = ffjttwitterEntitiesMedia
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterEntitiesDescription, kn) {
					currentKey = ffjttwitterEntitiesDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterEntitiesUserMentions, kn) {
					currentKey = ffjttwitterEntitiesUserMentions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterEntitiesURLs, kn) {
					currentKey = ffjttwitterEntitiesURLs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterEntitiesURL, kn) {
					currentKey = ffjttwitterEntitiesURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterEntitiesSymbols, kn) {
					currentKey = ffjttwitterEntitiesSymbols
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterEntitiesHashtags, kn) {
					currentKey = ffjttwitterEntitiesHashtags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjttwitterEntitiesnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjttwitterEntitiesHashtags:
					goto handle_Hashtags

				case ffjttwitterEntitiesSymbols:
					goto handle_Symbols

				case ffjttwitterEntitiesURL:
					goto handle_URL

				case ffjttwitterEntitiesURLs:
					goto handle_URLs

				case ffjttwitterEntitiesUserMentions:
					goto handle_UserMentions

				case ffjttwitterEntitiesDescription:
					goto handle_Description

				case ffjttwitterEntitiesMedia:
					goto handle_Media

				case ffjttwitterEntitiesnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Hashtags:

	/* handler: j.Hashtags type=[]interface {} kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Hashtags = nil
		} else {

			j.Hashtags = []interface{}{}

			wantVal := true

			for {

				var tmpJHashtags interface{}

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJHashtags type=interface {} kind=interface quoted=false*/

				{
					/* Falling back. type=interface {} kind=interface */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJHashtags)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.Hashtags = append(j.Hashtags, tmpJHashtags)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Symbols:

	/* handler: j.Symbols type=[]interface {} kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Symbols = nil
		} else {

			j.Symbols = []interface{}{}

			wantVal := true

			for {

				var tmpJSymbols interface{}

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJSymbols type=interface {} kind=interface quoted=false*/

				{
					/* Falling back. type=interface {} kind=interface */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJSymbols)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.Symbols = append(j.Symbols, tmpJSymbols)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: j.URL type=tmp.twitterURL kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.URL = nil

		} else {

			if j.URL == nil {
				j.URL = new(twitterURL)
			}

			err = j.URL.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URLs:

	/* handler: j.URLs type=[]tmp.twitterURL kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.URLs = nil
		} else {

			j.URLs = []twitterURL{}

			wantVal := true

			for {

				var tmpJURLs twitterURL

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJURLs type=tmp.twitterURL kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJURLs.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.URLs = append(j.URLs, tmpJURLs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserMentions:

	/* handler: j.UserMentions type=[]struct { ScreenName string "json:\"screen_name\""; Name string "json:\"name\""; ID int64 "json:\"id\""; IDStr int64 "json:\"id_str,string\""; Indices []int "json:\"indices\"" } kind=slice quoted=false*/

	{
		/* Falling back. type=[]struct { ScreenName string "json:\"screen_name\""; Name string "json:\"name\""; ID int64 "json:\"id\""; IDStr int64 "json:\"id_str,string\""; Indices []int "json:\"indices\"" } kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.UserMentions)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=struct { URLs []tmp.twitterURL "json:\"urls\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { URLs []tmp.twitterURL "json:\"urls\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Description)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Media:

	/* handler: j.Media type=[]struct { ID int64 "json:\"id\""; IDStr string "json:\"id_str\""; Indices []int "json:\"indices\""; MediaURL string "json:\"media_url\""; MediaURLHTTPS string "json:\"media_url_https\""; URL string "json:\"url\""; DisplayURL string "json:\"display_url\""; ExpandedURL string "json:\"expanded_url\""; Type string "json:\"type\""; Sizes map[string]struct { W int "json:\"w\""; H int "json:\"h\""; Resize string "json:\"resize\"" } "json:\"sizes\""; SourceStatusID int64 "json:\"source_status_id\""; SourceStatusIDStr int64 "json:\"source_status_id_str,string\"" } kind=slice quoted=false*/

	{
		/* Falling back. type=[]struct { ID int64 "json:\"id\""; IDStr string "json:\"id_str\""; Indices []int "json:\"indices\""; MediaURL string "json:\"media_url\""; MediaURLHTTPS string "json:\"media_url_https\""; URL string "json:\"url\""; DisplayURL string "json:\"display_url\""; ExpandedURL string "json:\"expanded_url\""; Type string "json:\"type\""; Sizes map[string]struct { W int "json:\"w\""; H int "json:\"h\""; Resize string "json:\"resize\"" } "json:\"sizes\""; SourceStatusID int64 "json:\"source_status_id\""; SourceStatusIDStr int64 "json:\"source_status_id_str,string\"" } kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Media)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *twitterRoot) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"statuses":`)
	if j.Statuses != nil {
		buf.WriteString(`[`)
		for i, v := range j.Statuses {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	/* Inline struct. type=struct { CompletedIn float64 "json:\"completed_in\""; MaxID int64 "json:\"max_id\""; MaxIDStr int64 "json:\"max_id_str,string\""; NextResults string "json:\"next_results\""; Query string "json:\"query\""; RefreshURL string "json:\"refresh_url\""; Count int "json:\"count\""; SinceID int "json:\"since_id\""; SinceIDStr int "json:\"since_id_str,string\"" } kind=struct */
	buf.WriteString(`,"search_metadata":{ "completed_in":`)
	fflib.AppendFloat(buf, float64(j.SearchMetadata.CompletedIn), 'g', -1, 64)
	buf.WriteString(`,"max_id":`)
	fflib.FormatBits2(buf, uint64(j.SearchMetadata.MaxID), 10, j.SearchMetadata.MaxID < 0)
	buf.WriteString(`,"max_id_str":"`)
	fflib.FormatBits2(buf, uint64(j.SearchMetadata.MaxIDStr), 10, j.SearchMetadata.MaxIDStr < 0)
	buf.WriteString(`","next_results":`)
	fflib.WriteJsonString(buf, string(j.SearchMetadata.NextResults))
	buf.WriteString(`,"query":`)
	fflib.WriteJsonString(buf, string(j.SearchMetadata.Query))
	buf.WriteString(`,"refresh_url":`)
	fflib.WriteJsonString(buf, string(j.SearchMetadata.RefreshURL))
	buf.WriteString(`,"count":`)
	fflib.FormatBits2(buf, uint64(j.SearchMetadata.Count), 10, j.SearchMetadata.Count < 0)
	buf.WriteString(`,"since_id":`)
	fflib.FormatBits2(buf, uint64(j.SearchMetadata.SinceID), 10, j.SearchMetadata.SinceID < 0)
	buf.WriteString(`,"since_id_str":"`)
	fflib.FormatBits2(buf, uint64(j.SearchMetadata.SinceIDStr), 10, j.SearchMetadata.SinceIDStr < 0)
	buf.WriteString(`"}`)
	buf.WriteByte('}')
	return nil
}

const (
	ffjttwitterRootbase = iota
	ffjttwitterRootnosuchkey

	ffjttwitterRootStatuses

	ffjttwitterRootSearchMetadata
)

var ffjKeytwitterRootStatuses = []byte("statuses")

var ffjKeytwitterRootSearchMetadata = []byte("search_metadata")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *twitterRoot) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjttwitterRootbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjttwitterRootnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 's':

					if bytes.Equal(ffjKeytwitterRootStatuses, kn) {
						currentKey = ffjttwitterRootStatuses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterRootSearchMetadata, kn) {
						currentKey = ffjttwitterRootSearchMetadata
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeytwitterRootSearchMetadata, kn) {
					currentKey = ffjttwitterRootSearchMetadata
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterRootStatuses, kn) {
					currentKey = ffjttwitterRootStatuses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjttwitterRootnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjttwitterRootStatuses:
					goto handle_Statuses

				case ffjttwitterRootSearchMetadata:
					goto handle_SearchMetadata

				case ffjttwitterRootnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Statuses:

	/* handler: j.Statuses type=[]tmp.twitterStatus kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Statuses = nil
		} else {

			j.Statuses = []twitterStatus{}

			wantVal := true

			for {

				var tmpJStatuses twitterStatus

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJStatuses type=tmp.twitterStatus kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJStatuses.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Statuses = append(j.Statuses, tmpJStatuses)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SearchMetadata:

	/* handler: j.SearchMetadata type=struct { CompletedIn float64 "json:\"completed_in\""; MaxID int64 "json:\"max_id\""; MaxIDStr int64 "json:\"max_id_str,string\""; NextResults string "json:\"next_results\""; Query string "json:\"query\""; RefreshURL string "json:\"refresh_url\""; Count int "json:\"count\""; SinceID int "json:\"since_id\""; SinceIDStr int "json:\"since_id_str,string\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { CompletedIn float64 "json:\"completed_in\""; MaxID int64 "json:\"max_id\""; MaxIDStr int64 "json:\"max_id_str,string\""; NextResults string "json:\"next_results\""; Query string "json:\"query\""; RefreshURL string "json:\"refresh_url\""; Count int "json:\"count\""; SinceID int "json:\"since_id\""; SinceIDStr int "json:\"since_id_str,string\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.SearchMetadata)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *twitterStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	/* Inline struct. type=struct { ResultType string "json:\"result_type\""; IsoLanguageCode string "json:\"iso_language_code\"" } kind=struct */
	buf.WriteString(`{"metadata":{ "result_type":`)
	fflib.WriteJsonString(buf, string(j.Metadata.ResultType))
	buf.WriteString(`,"iso_language_code":`)
	fflib.WriteJsonString(buf, string(j.Metadata.IsoLanguageCode))
	buf.WriteByte('}')
	buf.WriteString(`,"created_at":`)
	fflib.WriteJsonString(buf, string(j.CreatedAt))
	buf.WriteString(`,"id":`)
	fflib.FormatBits2(buf, uint64(j.ID), 10, j.ID < 0)
	buf.WriteString(`,"id_str":"`)
	fflib.FormatBits2(buf, uint64(j.IDStr), 10, j.IDStr < 0)
	buf.WriteString(`","text":`)
	fflib.WriteJsonString(buf, string(j.Text))
	buf.WriteString(`,"source":`)
	fflib.WriteJsonString(buf, string(j.Source))
	if j.Truncated {
		buf.WriteString(`,"truncated":true`)
	} else {
		buf.WriteString(`,"truncated":false`)
	}
	buf.WriteString(`,"in_reply_to_status_id":`)
	fflib.FormatBits2(buf, uint64(j.InReplyToStatusID), 10, j.InReplyToStatusID < 0)
	buf.WriteString(`,"in_reply_to_status_id_str":"`)
	fflib.FormatBits2(buf, uint64(j.InReplyToStatusIDStr), 10, j.InReplyToStatusIDStr < 0)
	buf.WriteString(`","in_reply_to_user_id":`)
	fflib.FormatBits2(buf, uint64(j.InReplyToUserID), 10, j.InReplyToUserID < 0)
	buf.WriteString(`,"in_reply_to_user_id_str":"`)
	fflib.FormatBits2(buf, uint64(j.InReplyToUserIDStr), 10, j.InReplyToUserIDStr < 0)
	buf.WriteString(`","in_reply_to_screen_name":`)
	fflib.WriteJsonString(buf, string(j.InReplyToScreenName))
	buf.WriteByte(',')
	if true {
		buf.WriteString(`"user":`)

		{

			err = j.User.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"geo":`)
	/* Interface types must use runtime reflection. type=interface {} kind=interface */
	err = buf.Encode(j.Geo)
	if err != nil {
		return err
	}
	buf.WriteString(`,"coordinates":`)
	/* Interface types must use runtime reflection. type=interface {} kind=interface */
	err = buf.Encode(j.Coordinates)
	if err != nil {
		return err
	}
	buf.WriteString(`,"place":`)
	/* Interface types must use runtime reflection. type=interface {} kind=interface */
	err = buf.Encode(j.Place)
	if err != nil {
		return err
	}
	buf.WriteString(`,"contributors":`)
	/* Interface types must use runtime reflection. type=interface {} kind=interface */
	err = buf.Encode(j.Contributors)
	if err != nil {
		return err
	}
	if j.RetweeetedStatus != nil {
		buf.WriteString(`,"retweeted_status":`)

		{

			err = j.RetweeetedStatus.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"retweeted_status":null`)
	}
	buf.WriteString(`,"retweet_count":`)
	fflib.FormatBits2(buf, uint64(j.RetweetCount), 10, j.RetweetCount < 0)
	buf.WriteString(`,"favorite_count":`)
	fflib.FormatBits2(buf, uint64(j.FavoriteCount), 10, j.FavoriteCount < 0)
	buf.WriteByte(',')
	if true {
		buf.WriteString(`"entities":`)

		{

			err = j.Entities.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
		buf.WriteByte(',')
	}
	if j.Favorited {
		buf.WriteString(`"favorited":true`)
	} else {
		buf.WriteString(`"favorited":false`)
	}
	if j.Retweeted {
		buf.WriteString(`,"retweeted":true`)
	} else {
		buf.WriteString(`,"retweeted":false`)
	}
	if j.PossiblySensitive {
		buf.WriteString(`,"possibly_sensitive":true`)
	} else {
		buf.WriteString(`,"possibly_sensitive":false`)
	}
	buf.WriteString(`,"lang":`)
	fflib.WriteJsonString(buf, string(j.Lang))
	buf.WriteByte('}')
	return nil
}

const (
	ffjttwitterStatusbase = iota
	ffjttwitterStatusnosuchkey

	ffjttwitterStatusMetadata

	ffjttwitterStatusCreatedAt

	ffjttwitterStatusID

	ffjttwitterStatusIDStr

	ffjttwitterStatusText

	ffjttwitterStatusSource

	ffjttwitterStatusTruncated

	ffjttwitterStatusInReplyToStatusID

	ffjttwitterStatusInReplyToStatusIDStr

	ffjttwitterStatusInReplyToUserID

	ffjttwitterStatusInReplyToUserIDStr

	ffjttwitterStatusInReplyToScreenName

	ffjttwitterStatusUser

	ffjttwitterStatusGeo

	ffjttwitterStatusCoordinates

	ffjttwitterStatusPlace

	ffjttwitterStatusContributors

	ffjttwitterStatusRetweeetedStatus

	ffjttwitterStatusRetweetCount

	ffjttwitterStatusFavoriteCount

	ffjttwitterStatusEntities

	ffjttwitterStatusFavorited

	ffjttwitterStatusRetweeted

	ffjttwitterStatusPossiblySensitive

	ffjttwitterStatusLang
)

var ffjKeytwitterStatusMetadata = []byte("metadata")

var ffjKeytwitterStatusCreatedAt = []byte("created_at")

var ffjKeytwitterStatusID = []byte("id")

var ffjKeytwitterStatusIDStr = []byte("id_str")

var ffjKeytwitterStatusText = []byte("text")

var ffjKeytwitterStatusSource = []byte("source")

var ffjKeytwitterStatusTruncated = []byte("truncated")

var ffjKeytwitterStatusInReplyToStatusID = []byte("in_reply_to_status_id")

var ffjKeytwitterStatusInReplyToStatusIDStr = []byte("in_reply_to_status_id_str")

var ffjKeytwitterStatusInReplyToUserID = []byte("in_reply_to_user_id")

var ffjKeytwitterStatusInReplyToUserIDStr = []byte("in_reply_to_user_id_str")

var ffjKeytwitterStatusInReplyToScreenName = []byte("in_reply_to_screen_name")

var ffjKeytwitterStatusUser = []byte("user")

var ffjKeytwitterStatusGeo = []byte("geo")

var ffjKeytwitterStatusCoordinates = []byte("coordinates")

var ffjKeytwitterStatusPlace = []byte("place")

var ffjKeytwitterStatusContributors = []byte("contributors")

var ffjKeytwitterStatusRetweeetedStatus = []byte("retweeted_status")

var ffjKeytwitterStatusRetweetCount = []byte("retweet_count")

var ffjKeytwitterStatusFavoriteCount = []byte("favorite_count")

var ffjKeytwitterStatusEntities = []byte("entities")

var ffjKeytwitterStatusFavorited = []byte("favorited")

var ffjKeytwitterStatusRetweeted = []byte("retweeted")

var ffjKeytwitterStatusPossiblySensitive = []byte("possibly_sensitive")

var ffjKeytwitterStatusLang = []byte("lang")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *twitterStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjttwitterStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjttwitterStatusnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeytwitterStatusCreatedAt, kn) {
						currentKey = ffjttwitterStatusCreatedAt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterStatusCoordinates, kn) {
						currentKey = ffjttwitterStatusCoordinates
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterStatusContributors, kn) {
						currentKey = ffjttwitterStatusContributors
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeytwitterStatusEntities, kn) {
						currentKey = ffjttwitterStatusEntities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeytwitterStatusFavoriteCount, kn) {
						currentKey = ffjttwitterStatusFavoriteCount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterStatusFavorited, kn) {
						currentKey = ffjttwitterStatusFavorited
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeytwitterStatusGeo, kn) {
						currentKey = ffjttwitterStatusGeo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeytwitterStatusID, kn) {
						currentKey = ffjttwitterStatusID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterStatusIDStr, kn) {
						currentKey = ffjttwitterStatusIDStr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterStatusInReplyToStatusID, kn) {
						currentKey = ffjttwitterStatusInReplyToStatusID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterStatusInReplyToStatusIDStr, kn) {
						currentKey = ffjttwitterStatusInReplyToStatusIDStr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterStatusInReplyToUserID, kn) {
						currentKey = ffjttwitterStatusInReplyToUserID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterStatusInReplyToUserIDStr, kn) {
						currentKey = ffjttwitterStatusInReplyToUserIDStr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterStatusInReplyToScreenName, kn) {
						currentKey = ffjttwitterStatusInReplyToScreenName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeytwitterStatusLang, kn) {
						currentKey = ffjttwitterStatusLang
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeytwitterStatusMetadata, kn) {
						currentKey = ffjttwitterStatusMetadata
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeytwitterStatusPlace, kn) {
						currentKey = ffjttwitterStatusPlace
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterStatusPossiblySensitive, kn) {
						currentKey = ffjttwitterStatusPossiblySensitive
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeytwitterStatusRetweeetedStatus, kn) {
						currentKey = ffjttwitterStatusRetweeetedStatus
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterStatusRetweetCount, kn) {
						currentKey = ffjttwitterStatusRetweetCount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterStatusRetweeted, kn) {
						currentKey = ffjttwitterStatusRetweeted
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeytwitterStatusSource, kn) {
						currentKey = ffjttwitterStatusSource
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeytwitterStatusText, kn) {
						currentKey = ffjttwitterStatusText
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterStatusTruncated, kn) {
						currentKey = ffjttwitterStatusTruncated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeytwitterStatusUser, kn) {
						currentKey = ffjttwitterStatusUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterStatusLang, kn) {
					currentKey = ffjttwitterStatusLang
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterStatusPossiblySensitive, kn) {
					currentKey = ffjttwitterStatusPossiblySensitive
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterStatusRetweeted, kn) {
					currentKey = ffjttwitterStatusRetweeted
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterStatusFavorited, kn) {
					currentKey = ffjttwitterStatusFavorited
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterStatusEntities, kn) {
					currentKey = ffjttwitterStatusEntities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeytwitterStatusFavoriteCount, kn) {
					currentKey = ffjttwitterStatusFavoriteCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeytwitterStatusRetweetCount, kn) {
					currentKey = ffjttwitterStatusRetweetCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterStatusRetweeetedStatus, kn) {
					currentKey = ffjttwitterStatusRetweeetedStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterStatusContributors, kn) {
					currentKey = ffjttwitterStatusContributors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterStatusPlace, kn) {
					currentKey = ffjttwitterStatusPlace
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterStatusCoordinates, kn) {
					currentKey = ffjttwitterStatusCoordinates
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterStatusGeo, kn) {
					currentKey = ffjttwitterStatusGeo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterStatusUser, kn) {
					currentKey = ffjttwitterStatusUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterStatusInReplyToScreenName, kn) {
					currentKey = ffjttwitterStatusInReplyToScreenName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterStatusInReplyToUserIDStr, kn) {
					currentKey = ffjttwitterStatusInReplyToUserIDStr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterStatusInReplyToUserID, kn) {
					currentKey = ffjttwitterStatusInReplyToUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterStatusInReplyToStatusIDStr, kn) {
					currentKey = ffjttwitterStatusInReplyToStatusIDStr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterStatusInReplyToStatusID, kn) {
					currentKey = ffjttwitterStatusInReplyToStatusID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterStatusTruncated, kn) {
					currentKey = ffjttwitterStatusTruncated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterStatusSource, kn) {
					currentKey = ffjttwitterStatusSource
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterStatusText, kn) {
					currentKey = ffjttwitterStatusText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterStatusIDStr, kn) {
					currentKey = ffjttwitterStatusIDStr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterStatusID, kn) {
					currentKey = ffjttwitterStatusID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeytwitterStatusCreatedAt, kn) {
					currentKey = ffjttwitterStatusCreatedAt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterStatusMetadata, kn) {
					currentKey = ffjttwitterStatusMetadata
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjttwitterStatusnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjttwitterStatusMetadata:
					goto handle_Metadata

				case ffjttwitterStatusCreatedAt:
					goto handle_CreatedAt

				case ffjttwitterStatusID:
					goto handle_ID

				case ffjttwitterStatusIDStr:
					goto handle_IDStr

				case ffjttwitterStatusText:
					goto handle_Text

				case ffjttwitterStatusSource:
					goto handle_Source

				case ffjttwitterStatusTruncated:
					goto handle_Truncated

				case ffjttwitterStatusInReplyToStatusID:
					goto handle_InReplyToStatusID

				case ffjttwitterStatusInReplyToStatusIDStr:
					goto handle_InReplyToStatusIDStr

				case ffjttwitterStatusInReplyToUserID:
					goto handle_InReplyToUserID

				case ffjttwitterStatusInReplyToUserIDStr:
					goto handle_InReplyToUserIDStr

				case ffjttwitterStatusInReplyToScreenName:
					goto handle_InReplyToScreenName

				case ffjttwitterStatusUser:
					goto handle_User

				case ffjttwitterStatusGeo:
					goto handle_Geo

				case ffjttwitterStatusCoordinates:
					goto handle_Coordinates

				case ffjttwitterStatusPlace:
					goto handle_Place

				case ffjttwitterStatusContributors:
					goto handle_Contributors

				case ffjttwitterStatusRetweeetedStatus:
					goto handle_RetweeetedStatus

				case ffjttwitterStatusRetweetCount:
					goto handle_RetweetCount

				case ffjttwitterStatusFavoriteCount:
					goto handle_FavoriteCount

				case ffjttwitterStatusEntities:
					goto handle_Entities

				case ffjttwitterStatusFavorited:
					goto handle_Favorited

				case ffjttwitterStatusRetweeted:
					goto handle_Retweeted

				case ffjttwitterStatusPossiblySensitive:
					goto handle_PossiblySensitive

				case ffjttwitterStatusLang:
					goto handle_Lang

				case ffjttwitterStatusnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Metadata:

	/* handler: j.Metadata type=struct { ResultType string "json:\"result_type\""; IsoLanguageCode string "json:\"iso_language_code\"" } kind=struct quoted=false*/

	{
		/* Falling back. type=struct { ResultType string "json:\"result_type\""; IsoLanguageCode string "json:\"iso_language_code\"" } kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Metadata)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreatedAt:

	/* handler: j.CreatedAt type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CreatedAt = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IDStr:

	/* handler: j.IDStr type=int64 kind=int64 quoted=true*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.IDStr = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Source:

	/* handler: j.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Source = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Truncated:

	/* handler: j.Truncated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Truncated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Truncated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InReplyToStatusID:

	/* handler: j.InReplyToStatusID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.InReplyToStatusID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InReplyToStatusIDStr:

	/* handler: j.InReplyToStatusIDStr type=int64 kind=int64 quoted=true*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.InReplyToStatusIDStr = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InReplyToUserID:

	/* handler: j.InReplyToUserID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.InReplyToUserID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InReplyToUserIDStr:

	/* handler: j.InReplyToUserIDStr type=int64 kind=int64 quoted=true*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null && tok != fflib.FFTok_string {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.InReplyToUserIDStr = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InReplyToScreenName:

	/* handler: j.InReplyToScreenName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InReplyToScreenName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=tmp.twitterUser kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Geo:

	/* handler: j.Geo type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Geo)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Coordinates:

	/* handler: j.Coordinates type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Coordinates)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Place:

	/* handler: j.Place type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Place)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Contributors:

	/* handler: j.Contributors type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Contributors)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RetweeetedStatus:

	/* handler: j.RetweeetedStatus type=tmp.twitterStatus kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.RetweeetedStatus = nil

		} else {

			if j.RetweeetedStatus == nil {
				j.RetweeetedStatus = new(twitterStatus)
			}

			err = j.RetweeetedStatus.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RetweetCount:

	/* handler: j.RetweetCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.RetweetCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FavoriteCount:

	/* handler: j.FavoriteCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FavoriteCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Entities:

	/* handler: j.Entities type=tmp.twitterEntities kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Entities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Favorited:

	/* handler: j.Favorited type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Favorited = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Favorited = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Retweeted:

	/* handler: j.Retweeted type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Retweeted = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Retweeted = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PossiblySensitive:

	/* handler: j.PossiblySensitive type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.PossiblySensitive = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.PossiblySensitive = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lang:

	/* handler: j.Lang type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lang = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *twitterURL) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"url":`)
	fflib.WriteJsonString(buf, string(j.URL))
	buf.WriteString(`,"urls":`)
	if j.URLs != nil {
		buf.WriteString(`[`)
		for i, v := range j.URLs {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"expanded_url":`)
	fflib.WriteJsonString(buf, string(j.ExpandedURL))
	buf.WriteString(`,"display_url":`)
	fflib.WriteJsonString(buf, string(j.DisplayURL))
	buf.WriteString(`,"indices":`)
	if j.Indices != nil {
		buf.WriteString(`[`)
		for i, v := range j.Indices {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, v < 0)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjttwitterURLbase = iota
	ffjttwitterURLnosuchkey

	ffjttwitterURLURL

	ffjttwitterURLURLs

	ffjttwitterURLExpandedURL

	ffjttwitterURLDisplayURL

	ffjttwitterURLIndices
)

var ffjKeytwitterURLURL = []byte("url")

var ffjKeytwitterURLURLs = []byte("urls")

var ffjKeytwitterURLExpandedURL = []byte("expanded_url")

var ffjKeytwitterURLDisplayURL = []byte("display_url")

var ffjKeytwitterURLIndices = []byte("indices")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *twitterURL) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjttwitterURLbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjttwitterURLnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeytwitterURLDisplayURL, kn) {
						currentKey = ffjttwitterURLDisplayURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeytwitterURLExpandedURL, kn) {
						currentKey = ffjttwitterURLExpandedURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeytwitterURLIndices, kn) {
						currentKey = ffjttwitterURLIndices
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeytwitterURLURL, kn) {
						currentKey = ffjttwitterURLURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterURLURLs, kn) {
						currentKey = ffjttwitterURLURLs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeytwitterURLIndices, kn) {
					currentKey = ffjttwitterURLIndices
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterURLDisplayURL, kn) {
					currentKey = ffjttwitterURLDisplayURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeytwitterURLExpandedURL, kn) {
					currentKey = ffjttwitterURLExpandedURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterURLURLs, kn) {
					currentKey = ffjttwitterURLURLs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterURLURL, kn) {
					currentKey = ffjttwitterURLURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjttwitterURLnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjttwitterURLURL:
					goto handle_URL

				case ffjttwitterURLURLs:
					goto handle_URLs

				case ffjttwitterURLExpandedURL:
					goto handle_ExpandedURL

				case ffjttwitterURLDisplayURL:
					goto handle_DisplayURL

				case ffjttwitterURLIndices:
					goto handle_Indices

				case ffjttwitterURLnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URLs:

	/* handler: j.URLs type=[]tmp.twitterURL kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.URLs = nil
		} else {

			j.URLs = []twitterURL{}

			wantVal := true

			for {

				var tmpJURLs twitterURL

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJURLs type=tmp.twitterURL kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJURLs.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.URLs = append(j.URLs, tmpJURLs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExpandedURL:

	/* handler: j.ExpandedURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ExpandedURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisplayURL:

	/* handler: j.DisplayURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.DisplayURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Indices:

	/* handler: j.Indices type=[]int kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Indices = nil
		} else {

			j.Indices = []int{}

			wantVal := true

			for {

				var tmpJIndices int

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJIndices type=int kind=int quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJIndices = int(tval)

					}
				}

				j.Indices = append(j.Indices, tmpJIndices)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *twitterUser) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.FormatBits2(buf, uint64(j.ID), 10, j.ID < 0)
	buf.WriteString(`,"id_str":`)
	fflib.WriteJsonString(buf, string(j.IDStr))
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"screen_name":`)
	fflib.WriteJsonString(buf, string(j.ScreenName))
	buf.WriteString(`,"location":`)
	fflib.WriteJsonString(buf, string(j.Location))
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"url":`)
	/* Interface types must use runtime reflection. type=interface {} kind=interface */
	err = buf.Encode(j.URL)
	if err != nil {
		return err
	}
	buf.WriteString(`,"entities":`)

	{

		err = j.Entities.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	if j.Protected {
		buf.WriteString(`,"protected":true`)
	} else {
		buf.WriteString(`,"protected":false`)
	}
	buf.WriteString(`,"followers_count":`)
	fflib.FormatBits2(buf, uint64(j.FollowersCount), 10, j.FollowersCount < 0)
	buf.WriteString(`,"friends_count":`)
	fflib.FormatBits2(buf, uint64(j.FriendsCount), 10, j.FriendsCount < 0)
	buf.WriteString(`,"listed_count":`)
	fflib.FormatBits2(buf, uint64(j.ListedCount), 10, j.ListedCount < 0)
	buf.WriteString(`,"created_at":`)
	fflib.WriteJsonString(buf, string(j.CreatedAt))
	buf.WriteString(`,"favourites_count":`)
	fflib.FormatBits2(buf, uint64(j.FavouritesCount), 10, j.FavouritesCount < 0)
	buf.WriteString(`,"utc_offset":`)
	fflib.FormatBits2(buf, uint64(j.UtcOffset), 10, j.UtcOffset < 0)
	buf.WriteString(`,"time_zone":`)
	fflib.WriteJsonString(buf, string(j.TimeZone))
	if j.GeoEnabled {
		buf.WriteString(`,"geo_enabled":true`)
	} else {
		buf.WriteString(`,"geo_enabled":false`)
	}
	if j.Verified {
		buf.WriteString(`,"verified":true`)
	} else {
		buf.WriteString(`,"verified":false`)
	}
	buf.WriteString(`,"statuses_count":`)
	fflib.FormatBits2(buf, uint64(j.StatusesCount), 10, j.StatusesCount < 0)
	buf.WriteString(`,"lang":`)
	fflib.WriteJsonString(buf, string(j.Lang))
	if j.ContributorsEnabled {
		buf.WriteString(`,"contributors_enabled":true`)
	} else {
		buf.WriteString(`,"contributors_enabled":false`)
	}
	if j.IsTranslator {
		buf.WriteString(`,"is_translator":true`)
	} else {
		buf.WriteString(`,"is_translator":false`)
	}
	if j.IsTranslationEnabled {
		buf.WriteString(`,"is_translation_enabled":true`)
	} else {
		buf.WriteString(`,"is_translation_enabled":false`)
	}
	buf.WriteString(`,"profile_background_color":`)
	fflib.WriteJsonString(buf, string(j.ProfileBackgroundColor))
	buf.WriteString(`,"profile_background_image_url":`)
	fflib.WriteJsonString(buf, string(j.ProfileBackgroundImageURL))
	buf.WriteString(`,"profile_background_image_url_https":`)
	fflib.WriteJsonString(buf, string(j.ProfileBackgroundImageURLHTTPS))
	if j.ProfileBackgroundTile {
		buf.WriteString(`,"profile_background_tile":true`)
	} else {
		buf.WriteString(`,"profile_background_tile":false`)
	}
	buf.WriteString(`,"profile_image_url":`)
	fflib.WriteJsonString(buf, string(j.ProfileImageURL))
	buf.WriteString(`,"profile_image_url_https":`)
	fflib.WriteJsonString(buf, string(j.ProfileImageURLHTTPS))
	buf.WriteString(`,"profile_banner_url":`)
	fflib.WriteJsonString(buf, string(j.ProfileBannerURL))
	buf.WriteString(`,"profile_link_color":`)
	fflib.WriteJsonString(buf, string(j.ProfileLinkColor))
	buf.WriteString(`,"profile_sidebar_border_color":`)
	fflib.WriteJsonString(buf, string(j.ProfileSidebarBorderColor))
	buf.WriteString(`,"profile_sidebar_fill_color":`)
	fflib.WriteJsonString(buf, string(j.ProfileSidebarFillColor))
	buf.WriteString(`,"profile_text_color":`)
	fflib.WriteJsonString(buf, string(j.ProfileTextColor))
	if j.ProfileUseBackgroundImage {
		buf.WriteString(`,"profile_use_background_image":true`)
	} else {
		buf.WriteString(`,"profile_use_background_image":false`)
	}
	if j.DefaultProfile {
		buf.WriteString(`,"default_profile":true`)
	} else {
		buf.WriteString(`,"default_profile":false`)
	}
	if j.DefaultProfileImage {
		buf.WriteString(`,"default_profile_image":true`)
	} else {
		buf.WriteString(`,"default_profile_image":false`)
	}
	if j.Following {
		buf.WriteString(`,"following":true`)
	} else {
		buf.WriteString(`,"following":false`)
	}
	if j.FollowRequestSent {
		buf.WriteString(`,"follow_request_sent":true`)
	} else {
		buf.WriteString(`,"follow_request_sent":false`)
	}
	if j.Notifications {
		buf.WriteString(`,"notifications":true`)
	} else {
		buf.WriteString(`,"notifications":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjttwitterUserbase = iota
	ffjttwitterUsernosuchkey

	ffjttwitterUserID

	ffjttwitterUserIDStr

	ffjttwitterUserName

	ffjttwitterUserScreenName

	ffjttwitterUserLocation

	ffjttwitterUserDescription

	ffjttwitterUserURL

	ffjttwitterUserEntities

	ffjttwitterUserProtected

	ffjttwitterUserFollowersCount

	ffjttwitterUserFriendsCount

	ffjttwitterUserListedCount

	ffjttwitterUserCreatedAt

	ffjttwitterUserFavouritesCount

	ffjttwitterUserUtcOffset

	ffjttwitterUserTimeZone

	ffjttwitterUserGeoEnabled

	ffjttwitterUserVerified

	ffjttwitterUserStatusesCount

	ffjttwitterUserLang

	ffjttwitterUserContributorsEnabled

	ffjttwitterUserIsTranslator

	ffjttwitterUserIsTranslationEnabled

	ffjttwitterUserProfileBackgroundColor

	ffjttwitterUserProfileBackgroundImageURL

	ffjttwitterUserProfileBackgroundImageURLHTTPS

	ffjttwitterUserProfileBackgroundTile

	ffjttwitterUserProfileImageURL

	ffjttwitterUserProfileImageURLHTTPS

	ffjttwitterUserProfileBannerURL

	ffjttwitterUserProfileLinkColor

	ffjttwitterUserProfileSidebarBorderColor

	ffjttwitterUserProfileSidebarFillColor

	ffjttwitterUserProfileTextColor

	ffjttwitterUserProfileUseBackgroundImage

	ffjttwitterUserDefaultProfile

	ffjttwitterUserDefaultProfileImage

	ffjttwitterUserFollowing

	ffjttwitterUserFollowRequestSent

	ffjttwitterUserNotifications
)

var ffjKeytwitterUserID = []byte("id")

var ffjKeytwitterUserIDStr = []byte("id_str")

var ffjKeytwitterUserName = []byte("name")

var ffjKeytwitterUserScreenName = []byte("screen_name")

var ffjKeytwitterUserLocation = []byte("location")

var ffjKeytwitterUserDescription = []byte("description")

var ffjKeytwitterUserURL = []byte("url")

var ffjKeytwitterUserEntities = []byte("entities")

var ffjKeytwitterUserProtected = []byte("protected")

var ffjKeytwitterUserFollowersCount = []byte("followers_count")

var ffjKeytwitterUserFriendsCount = []byte("friends_count")

var ffjKeytwitterUserListedCount = []byte("listed_count")

var ffjKeytwitterUserCreatedAt = []byte("created_at")

var ffjKeytwitterUserFavouritesCount = []byte("favourites_count")

var ffjKeytwitterUserUtcOffset = []byte("utc_offset")

var ffjKeytwitterUserTimeZone = []byte("time_zone")

var ffjKeytwitterUserGeoEnabled = []byte("geo_enabled")

var ffjKeytwitterUserVerified = []byte("verified")

var ffjKeytwitterUserStatusesCount = []byte("statuses_count")

var ffjKeytwitterUserLang = []byte("lang")

var ffjKeytwitterUserContributorsEnabled = []byte("contributors_enabled")

var ffjKeytwitterUserIsTranslator = []byte("is_translator")

var ffjKeytwitterUserIsTranslationEnabled = []byte("is_translation_enabled")

var ffjKeytwitterUserProfileBackgroundColor = []byte("profile_background_color")

var ffjKeytwitterUserProfileBackgroundImageURL = []byte("profile_background_image_url")

var ffjKeytwitterUserProfileBackgroundImageURLHTTPS = []byte("profile_background_image_url_https")

var ffjKeytwitterUserProfileBackgroundTile = []byte("profile_background_tile")

var ffjKeytwitterUserProfileImageURL = []byte("profile_image_url")

var ffjKeytwitterUserProfileImageURLHTTPS = []byte("profile_image_url_https")

var ffjKeytwitterUserProfileBannerURL = []byte("profile_banner_url")

var ffjKeytwitterUserProfileLinkColor = []byte("profile_link_color")

var ffjKeytwitterUserProfileSidebarBorderColor = []byte("profile_sidebar_border_color")

var ffjKeytwitterUserProfileSidebarFillColor = []byte("profile_sidebar_fill_color")

var ffjKeytwitterUserProfileTextColor = []byte("profile_text_color")

var ffjKeytwitterUserProfileUseBackgroundImage = []byte("profile_use_background_image")

var ffjKeytwitterUserDefaultProfile = []byte("default_profile")

var ffjKeytwitterUserDefaultProfileImage = []byte("default_profile_image")

var ffjKeytwitterUserFollowing = []byte("following")

var ffjKeytwitterUserFollowRequestSent = []byte("follow_request_sent")

var ffjKeytwitterUserNotifications = []byte("notifications")

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *twitterUser) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjttwitterUserbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjttwitterUsernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeytwitterUserCreatedAt, kn) {
						currentKey = ffjttwitterUserCreatedAt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserContributorsEnabled, kn) {
						currentKey = ffjttwitterUserContributorsEnabled
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeytwitterUserDescription, kn) {
						currentKey = ffjttwitterUserDescription
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserDefaultProfile, kn) {
						currentKey = ffjttwitterUserDefaultProfile
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserDefaultProfileImage, kn) {
						currentKey = ffjttwitterUserDefaultProfileImage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeytwitterUserEntities, kn) {
						currentKey = ffjttwitterUserEntities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeytwitterUserFollowersCount, kn) {
						currentKey = ffjttwitterUserFollowersCount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserFriendsCount, kn) {
						currentKey = ffjttwitterUserFriendsCount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserFavouritesCount, kn) {
						currentKey = ffjttwitterUserFavouritesCount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserFollowing, kn) {
						currentKey = ffjttwitterUserFollowing
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserFollowRequestSent, kn) {
						currentKey = ffjttwitterUserFollowRequestSent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeytwitterUserGeoEnabled, kn) {
						currentKey = ffjttwitterUserGeoEnabled
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeytwitterUserID, kn) {
						currentKey = ffjttwitterUserID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserIDStr, kn) {
						currentKey = ffjttwitterUserIDStr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserIsTranslator, kn) {
						currentKey = ffjttwitterUserIsTranslator
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserIsTranslationEnabled, kn) {
						currentKey = ffjttwitterUserIsTranslationEnabled
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeytwitterUserLocation, kn) {
						currentKey = ffjttwitterUserLocation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserListedCount, kn) {
						currentKey = ffjttwitterUserListedCount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserLang, kn) {
						currentKey = ffjttwitterUserLang
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeytwitterUserName, kn) {
						currentKey = ffjttwitterUserName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserNotifications, kn) {
						currentKey = ffjttwitterUserNotifications
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeytwitterUserProtected, kn) {
						currentKey = ffjttwitterUserProtected
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserProfileBackgroundColor, kn) {
						currentKey = ffjttwitterUserProfileBackgroundColor
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserProfileBackgroundImageURL, kn) {
						currentKey = ffjttwitterUserProfileBackgroundImageURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserProfileBackgroundImageURLHTTPS, kn) {
						currentKey = ffjttwitterUserProfileBackgroundImageURLHTTPS
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserProfileBackgroundTile, kn) {
						currentKey = ffjttwitterUserProfileBackgroundTile
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserProfileImageURL, kn) {
						currentKey = ffjttwitterUserProfileImageURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserProfileImageURLHTTPS, kn) {
						currentKey = ffjttwitterUserProfileImageURLHTTPS
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserProfileBannerURL, kn) {
						currentKey = ffjttwitterUserProfileBannerURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserProfileLinkColor, kn) {
						currentKey = ffjttwitterUserProfileLinkColor
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserProfileSidebarBorderColor, kn) {
						currentKey = ffjttwitterUserProfileSidebarBorderColor
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserProfileSidebarFillColor, kn) {
						currentKey = ffjttwitterUserProfileSidebarFillColor
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserProfileTextColor, kn) {
						currentKey = ffjttwitterUserProfileTextColor
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserProfileUseBackgroundImage, kn) {
						currentKey = ffjttwitterUserProfileUseBackgroundImage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeytwitterUserScreenName, kn) {
						currentKey = ffjttwitterUserScreenName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserStatusesCount, kn) {
						currentKey = ffjttwitterUserStatusesCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeytwitterUserTimeZone, kn) {
						currentKey = ffjttwitterUserTimeZone
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeytwitterUserURL, kn) {
						currentKey = ffjttwitterUserURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeytwitterUserUtcOffset, kn) {
						currentKey = ffjttwitterUserUtcOffset
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeytwitterUserVerified, kn) {
						currentKey = ffjttwitterUserVerified
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeytwitterUserNotifications, kn) {
					currentKey = ffjttwitterUserNotifications
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserFollowRequestSent, kn) {
					currentKey = ffjttwitterUserFollowRequestSent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterUserFollowing, kn) {
					currentKey = ffjttwitterUserFollowing
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeytwitterUserDefaultProfileImage, kn) {
					currentKey = ffjttwitterUserDefaultProfileImage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeytwitterUserDefaultProfile, kn) {
					currentKey = ffjttwitterUserDefaultProfile
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserProfileUseBackgroundImage, kn) {
					currentKey = ffjttwitterUserProfileUseBackgroundImage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeytwitterUserProfileTextColor, kn) {
					currentKey = ffjttwitterUserProfileTextColor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserProfileSidebarFillColor, kn) {
					currentKey = ffjttwitterUserProfileSidebarFillColor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserProfileSidebarBorderColor, kn) {
					currentKey = ffjttwitterUserProfileSidebarBorderColor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserProfileLinkColor, kn) {
					currentKey = ffjttwitterUserProfileLinkColor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeytwitterUserProfileBannerURL, kn) {
					currentKey = ffjttwitterUserProfileBannerURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserProfileImageURLHTTPS, kn) {
					currentKey = ffjttwitterUserProfileImageURLHTTPS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeytwitterUserProfileImageURL, kn) {
					currentKey = ffjttwitterUserProfileImageURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserProfileBackgroundTile, kn) {
					currentKey = ffjttwitterUserProfileBackgroundTile
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserProfileBackgroundImageURLHTTPS, kn) {
					currentKey = ffjttwitterUserProfileBackgroundImageURLHTTPS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserProfileBackgroundImageURL, kn) {
					currentKey = ffjttwitterUserProfileBackgroundImageURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserProfileBackgroundColor, kn) {
					currentKey = ffjttwitterUserProfileBackgroundColor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserIsTranslationEnabled, kn) {
					currentKey = ffjttwitterUserIsTranslationEnabled
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserIsTranslator, kn) {
					currentKey = ffjttwitterUserIsTranslator
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserContributorsEnabled, kn) {
					currentKey = ffjttwitterUserContributorsEnabled
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterUserLang, kn) {
					currentKey = ffjttwitterUserLang
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserStatusesCount, kn) {
					currentKey = ffjttwitterUserStatusesCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterUserVerified, kn) {
					currentKey = ffjttwitterUserVerified
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeytwitterUserGeoEnabled, kn) {
					currentKey = ffjttwitterUserGeoEnabled
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeytwitterUserTimeZone, kn) {
					currentKey = ffjttwitterUserTimeZone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserUtcOffset, kn) {
					currentKey = ffjttwitterUserUtcOffset
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserFavouritesCount, kn) {
					currentKey = ffjttwitterUserFavouritesCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeytwitterUserCreatedAt, kn) {
					currentKey = ffjttwitterUserCreatedAt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserListedCount, kn) {
					currentKey = ffjttwitterUserListedCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserFriendsCount, kn) {
					currentKey = ffjttwitterUserFriendsCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserFollowersCount, kn) {
					currentKey = ffjttwitterUserFollowersCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterUserProtected, kn) {
					currentKey = ffjttwitterUserProtected
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserEntities, kn) {
					currentKey = ffjttwitterUserEntities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterUserURL, kn) {
					currentKey = ffjttwitterUserURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserDescription, kn) {
					currentKey = ffjttwitterUserDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterUserLocation, kn) {
					currentKey = ffjttwitterUserLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserScreenName, kn) {
					currentKey = ffjttwitterUserScreenName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterUserName, kn) {
					currentKey = ffjttwitterUserName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeytwitterUserIDStr, kn) {
					currentKey = ffjttwitterUserIDStr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeytwitterUserID, kn) {
					currentKey = ffjttwitterUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjttwitterUsernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjttwitterUserID:
					goto handle_ID

				case ffjttwitterUserIDStr:
					goto handle_IDStr

				case ffjttwitterUserName:
					goto handle_Name

				case ffjttwitterUserScreenName:
					goto handle_ScreenName

				case ffjttwitterUserLocation:
					goto handle_Location

				case ffjttwitterUserDescription:
					goto handle_Description

				case ffjttwitterUserURL:
					goto handle_URL

				case ffjttwitterUserEntities:
					goto handle_Entities

				case ffjttwitterUserProtected:
					goto handle_Protected

				case ffjttwitterUserFollowersCount:
					goto handle_FollowersCount

				case ffjttwitterUserFriendsCount:
					goto handle_FriendsCount

				case ffjttwitterUserListedCount:
					goto handle_ListedCount

				case ffjttwitterUserCreatedAt:
					goto handle_CreatedAt

				case ffjttwitterUserFavouritesCount:
					goto handle_FavouritesCount

				case ffjttwitterUserUtcOffset:
					goto handle_UtcOffset

				case ffjttwitterUserTimeZone:
					goto handle_TimeZone

				case ffjttwitterUserGeoEnabled:
					goto handle_GeoEnabled

				case ffjttwitterUserVerified:
					goto handle_Verified

				case ffjttwitterUserStatusesCount:
					goto handle_StatusesCount

				case ffjttwitterUserLang:
					goto handle_Lang

				case ffjttwitterUserContributorsEnabled:
					goto handle_ContributorsEnabled

				case ffjttwitterUserIsTranslator:
					goto handle_IsTranslator

				case ffjttwitterUserIsTranslationEnabled:
					goto handle_IsTranslationEnabled

				case ffjttwitterUserProfileBackgroundColor:
					goto handle_ProfileBackgroundColor

				case ffjttwitterUserProfileBackgroundImageURL:
					goto handle_ProfileBackgroundImageURL

				case ffjttwitterUserProfileBackgroundImageURLHTTPS:
					goto handle_ProfileBackgroundImageURLHTTPS

				case ffjttwitterUserProfileBackgroundTile:
					goto handle_ProfileBackgroundTile

				case ffjttwitterUserProfileImageURL:
					goto handle_ProfileImageURL

				case ffjttwitterUserProfileImageURLHTTPS:
					goto handle_ProfileImageURLHTTPS

				case ffjttwitterUserProfileBannerURL:
					goto handle_ProfileBannerURL

				case ffjttwitterUserProfileLinkColor:
					goto handle_ProfileLinkColor

				case ffjttwitterUserProfileSidebarBorderColor:
					goto handle_ProfileSidebarBorderColor

				case ffjttwitterUserProfileSidebarFillColor:
					goto handle_ProfileSidebarFillColor

				case ffjttwitterUserProfileTextColor:
					goto handle_ProfileTextColor

				case ffjttwitterUserProfileUseBackgroundImage:
					goto handle_ProfileUseBackgroundImage

				case ffjttwitterUserDefaultProfile:
					goto handle_DefaultProfile

				case ffjttwitterUserDefaultProfileImage:
					goto handle_DefaultProfileImage

				case ffjttwitterUserFollowing:
					goto handle_Following

				case ffjttwitterUserFollowRequestSent:
					goto handle_FollowRequestSent

				case ffjttwitterUserNotifications:
					goto handle_Notifications

				case ffjttwitterUsernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IDStr:

	/* handler: j.IDStr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.IDStr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ScreenName:

	/* handler: j.ScreenName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ScreenName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: j.Location type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Location = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: j.URL type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.URL)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Entities:

	/* handler: j.Entities type=tmp.twitterEntities kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Entities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Protected:

	/* handler: j.Protected type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Protected = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Protected = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FollowersCount:

	/* handler: j.FollowersCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FollowersCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FriendsCount:

	/* handler: j.FriendsCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FriendsCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ListedCount:

	/* handler: j.ListedCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ListedCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreatedAt:

	/* handler: j.CreatedAt type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CreatedAt = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FavouritesCount:

	/* handler: j.FavouritesCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FavouritesCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UtcOffset:

	/* handler: j.UtcOffset type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.UtcOffset = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TimeZone:

	/* handler: j.TimeZone type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.TimeZone = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GeoEnabled:

	/* handler: j.GeoEnabled type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.GeoEnabled = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.GeoEnabled = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Verified:

	/* handler: j.Verified type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Verified = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Verified = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StatusesCount:

	/* handler: j.StatusesCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.StatusesCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lang:

	/* handler: j.Lang type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lang = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContributorsEnabled:

	/* handler: j.ContributorsEnabled type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ContributorsEnabled = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ContributorsEnabled = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsTranslator:

	/* handler: j.IsTranslator type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsTranslator = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsTranslator = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsTranslationEnabled:

	/* handler: j.IsTranslationEnabled type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsTranslationEnabled = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsTranslationEnabled = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfileBackgroundColor:

	/* handler: j.ProfileBackgroundColor type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProfileBackgroundColor = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfileBackgroundImageURL:

	/* handler: j.ProfileBackgroundImageURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProfileBackgroundImageURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfileBackgroundImageURLHTTPS:

	/* handler: j.ProfileBackgroundImageURLHTTPS type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProfileBackgroundImageURLHTTPS = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfileBackgroundTile:

	/* handler: j.ProfileBackgroundTile type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ProfileBackgroundTile = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ProfileBackgroundTile = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfileImageURL:

	/* handler: j.ProfileImageURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProfileImageURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfileImageURLHTTPS:

	/* handler: j.ProfileImageURLHTTPS type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProfileImageURLHTTPS = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfileBannerURL:

	/* handler: j.ProfileBannerURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProfileBannerURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfileLinkColor:

	/* handler: j.ProfileLinkColor type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProfileLinkColor = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfileSidebarBorderColor:

	/* handler: j.ProfileSidebarBorderColor type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProfileSidebarBorderColor = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfileSidebarFillColor:

	/* handler: j.ProfileSidebarFillColor type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProfileSidebarFillColor = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfileTextColor:

	/* handler: j.ProfileTextColor type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProfileTextColor = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfileUseBackgroundImage:

	/* handler: j.ProfileUseBackgroundImage type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ProfileUseBackgroundImage = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ProfileUseBackgroundImage = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DefaultProfile:

	/* handler: j.DefaultProfile type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DefaultProfile = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DefaultProfile = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DefaultProfileImage:

	/* handler: j.DefaultProfileImage type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DefaultProfileImage = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DefaultProfileImage = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Following:

	/* handler: j.Following type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Following = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Following = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FollowRequestSent:

	/* handler: j.FollowRequestSent type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.FollowRequestSent = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.FollowRequestSent = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Notifications:

	/* handler: j.Notifications type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Notifications = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Notifications = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
